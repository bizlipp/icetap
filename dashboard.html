<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inspiro Analytics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    .corporate-header {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      padding: 15px;
      background: #1e1e1e;
      border-radius: 5px;
    }
    .dashboard-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .dashboard-card {
      background: #222;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .card-header {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .accent-color {
      color: #a43ec9;
    }
    .positive-color {
      color: #4caf50;
    }
    .negative-color {
      color: #ff4d4d;
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .stat-card {
      background: #2a2a2a;
      border-radius: 5px;
      padding: 15px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .stat-label {
      font-size: 14px;
      color: #aaa;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    th {
      background-color: #2a2a2a;
      color: #ccc;
    }
    .data-controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #222;
      border-radius: 5px;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    button {
      padding: 8px 15px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .primary-button {
      background: #a43ec9;
      border-color: #a43ec9;
    }
    button:hover {
      background: #444 !important;
    }
    .primary-button:hover {
      background: #b44dd9 !important;
      border-color: #b44dd9;
    }
    .no-data-message {
      text-align: center;
      padding: 30px;
      color: #888;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="corporate-header">
    <h1 style="font-family: Arial, sans-serif;">
      <span style="color: #000; font-size: 42px; font-weight: 900;">inspi</span><span style="color: #a43ec9; font-size: 42px; font-weight: 900;">r</span><span style="color: #000; font-size: 42px; font-weight: 900;">o</span> <span style="font-size: 28px; font-weight: bold;">Analytics Dashboard</span>
    </h1>
    <p>Comprehensive analytics of call transcripts for enhanced customer service performance.</p>
  </div>

  <div class="data-controls">
    <button id="loadDataButton" class="primary-button">Load Data from Parser</button>
    <button id="refreshButton">Refresh Dashboard</button>
    <div id="dataStatus">No data loaded</div>
  </div>

  <div class="dashboard-container">
    <!-- Summary Statistics -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üìä Call Statistics Summary</span>
      </div>
      <div class="stat-grid">
        <div class="stat-card">
          <div class="stat-label">Total Calls</div>
          <div class="stat-value" id="totalCalls">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Flagged Calls</div>
          <div class="stat-value negative-color" id="flaggedCalls">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Positive Calls</div>
          <div class="stat-value positive-color" id="positiveCalls">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Avg. Call Duration</div>
          <div class="stat-value" id="avgDuration">0 min</div>
        </div>
      </div>
    </div>

    <!-- Agent Performance -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üë• Agent Performance</span>
      </div>
      <div class="chart-container">
        <canvas id="agentPerformanceChart"></canvas>
      </div>
    </div>

    <!-- Flag Distribution -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üö© Flag Distribution</span>
      </div>
      <div class="chart-container">
        <canvas id="flagDistributionChart"></canvas>
      </div>
    </div>
    
    <!-- Positive Indicators -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üåü Positive Indicators</span>
      </div>
      <div class="chart-container">
        <canvas id="positiveIndicatorsChart"></canvas>
      </div>
    </div>
  </div>
  
  <div class="dashboard-container">
    <!-- Time Distribution -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>‚è∞ Call Time Distribution</span>
      </div>
      <div class="chart-container">
        <canvas id="timeDistributionChart"></canvas>
      </div>
      <div class="chart-container" style="margin-top: 20px;">
        <canvas id="dayDistributionChart"></canvas>
      </div>
    </div>
    
    <!-- Channel & Queue Distribution -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üì± Channel & Queue Distribution</span>
      </div>
      <div style="display: flex; gap: 20px;">
        <div style="flex: 1;">
          <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Channels</h3>
          <div class="chart-container" style="height: 200px;">
            <canvas id="channelDistributionChart"></canvas>
          </div>
        </div>
        <div style="flex: 1;">
          <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Queues</h3>
          <div class="chart-container" style="height: 200px;">
            <canvas id="queueDistributionChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="dashboard-container">
    <!-- Repeat Callers Analysis -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üîÅ Repeat Callers Analysis</span>
      </div>
      <table>
        <thead>
          <tr>
            <th>Customer Phone</th>
            <th>Call Count</th>
            <th>Latest Call</th>
            <th>First Call</th>
            <th>Common Flags</th>
          </tr>
        </thead>
        <tbody id="repeatCallersBody">
          <tr>
            <td colspan="5" class="no-data-message">No data available</td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <!-- Common Topics -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üîç Common Topics</span>
      </div>
      <div id="commonTopics" style="padding: 10px; display: flex; flex-wrap: wrap; gap: 8px;">
        <div class="no-data-message">No data available</div>
      </div>
    </div>
  </div>
  
  <div class="dashboard-container">
    <!-- Categories Analysis -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üìä Categories Analysis</span>
      </div>
      <div class="chart-container">
        <canvas id="categoriesChart"></canvas>
      </div>
      <div id="categoryDetails" style="margin-top: 15px; padding: 10px;">
        <div class="no-data-message">No categories data available</div>
      </div>
    </div>
  </div>
  
  <div class="dashboard-container">
    <!-- Top Agents Table -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>üèÜ Top Performing Agents</span>
      </div>
      <table id="topAgentsTable">
        <thead>
          <tr>
            <th>Agent</th>
            <th>Total Calls</th>
            <th>Positive Ratio</th>
            <th>Avg Score</th>
            <th>Avg Duration</th>
          </tr>
        </thead>
        <tbody id="topAgentsBody">
          <tr>
            <td colspan="5" class="no-data-message">No data available</td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <!-- Recent Positive Calls -->
    <div class="dashboard-card">
      <div class="card-header">
        <span>‚úÖ Recent Positive Calls</span>
      </div>
      <div id="positiveCallsList">
        <div class="no-data-message">No data available</div>
      </div>
    </div>
  </div>

  <script>
    // Dashboard state
    let dashboardData = {
      calls: [],
      agents: {},
      flags: {},
      positiveFlags: {},
      hourDistribution: new Array(24).fill(0),
      dayDistribution: new Array(7).fill(0),
      channelDistribution: {},
      queueDistribution: {},
      wordFrequency: {},
      repeatCallers: {},
      categories: {},
      loaded: false
    };
    
    // DOM elements
    const loadDataButton = document.getElementById('loadDataButton');
    const refreshButton = document.getElementById('refreshButton');
    const dataStatus = document.getElementById('dataStatus');
    
    // Chart objects
    let agentPerformanceChart = null;
    let flagDistributionChart = null;
    let positiveIndicatorsChart = null;
    let timeDistributionChart = null;
    let dayDistributionChart = null;
    let channelDistributionChart = null;
    let queueDistributionChart = null;
    let categoriesChart = null;
    
    // Constants
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      loadDataButton.addEventListener('click', loadDataFromParser);
      refreshButton.addEventListener('click', refreshDashboard);
    });
    
    // Load data from localStorage
    async function loadDataFromParser() {
      dataStatus.textContent = "Attempting to load data...";
      
      try {
        // Try to get data from localStorage
        const storedData = localStorage.getItem('inspiroCallData');
        
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            if (Array.isArray(parsedData) && parsedData.length > 0) {
              dashboardData.calls = parsedData;
              processData();
              dataStatus.textContent = `‚úÖ Loaded ${dashboardData.calls.length} calls`;
              dashboardData.loaded = true;
              refreshDashboard();
              return;
            }
          } catch (parseError) {
            console.error("Error parsing stored data:", parseError);
          }
        }
        
        dataStatus.textContent = "No data found. Please parse calls in the main tool first.";
      } catch (error) {
        dataStatus.textContent = `‚ùå Error: ${error.message}`;
        console.error(error);
      }
    }
    
    // Process the raw call data into usable statistics
    function processData() {
      // Reset processed data
      dashboardData.agents = {};
      dashboardData.flags = {};
      dashboardData.positiveFlags = {};
      dashboardData.hourDistribution = new Array(24).fill(0);
      dashboardData.dayDistribution = new Array(7).fill(0);
      dashboardData.channelDistribution = {};
      dashboardData.queueDistribution = {};
      dashboardData.wordFrequency = {};
      dashboardData.repeatCallers = {};
      dashboardData.categories = {};
      
      // Process each call
      dashboardData.calls.forEach(call => {
        // Agent data
        const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
        if (!dashboardData.agents[agent]) {
          dashboardData.agents[agent] = {
            name: agent,
            totalCalls: 0,
            flaggedCalls: 0,
            positiveCalls: 0,
            positiveScore: 0,
            avgDuration: 0,
            totalDuration: 0
          };
        }
        
        // Increment agent stats
        const agentData = dashboardData.agents[agent];
        agentData.totalCalls++;
        
        if (call.flags && call.flags.length > 0) {
          agentData.flaggedCalls++;
        }
        
        if (call.positiveFlags && call.positiveFlags.length > 0) {
          agentData.positiveCalls++;
        }
        
        // Track positive score
        agentData.positiveScore += (call.positiveScore || 0);
        
        // Track call duration
        const durationText = call.meta["Contact duration"] || "0";
        const durationMinutes = parseDuration(durationText);
        agentData.totalDuration += durationMinutes;
        
        // Track flags
        if (call.flags) {
          call.flags.forEach(flag => {
            dashboardData.flags[flag] = (dashboardData.flags[flag] || 0) + 1;
          });
        }
        
        // Track positive flags
        if (call.positiveFlags) {
          call.positiveFlags.forEach(flag => {
            dashboardData.positiveFlags[flag] = (dashboardData.positiveFlags[flag] || 0) + 1;
          });
        }
        
        // Track time distribution
        try {
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              // Hour distribution
              const hour = date.getHours();
              dashboardData.hourDistribution[hour]++;
              
              // Day of week distribution
              const day = date.getDay();
              dashboardData.dayDistribution[day]++;
            }
          }
        } catch (error) {
          console.error("Error processing timestamp:", error);
        }
        
        // Track channel and queue
        const channel = call.meta["Channel"] || "Unknown";
        dashboardData.channelDistribution[channel] = (dashboardData.channelDistribution[channel] || 0) + 1;
        
        const queue = call.meta["Queue"] || "Unknown";
        dashboardData.queueDistribution[queue] = (dashboardData.queueDistribution[queue] || 0) + 1;
        
        // Track word frequency in transcripts
        if (call.transcript && call.transcript.length > 0) {
          call.transcript.forEach(entry => {
            if (entry.text) {
              const text = entry.text.toLowerCase();
              const words = text.split(/\s+/).filter(word => 
                word.length > 3 && 
                ![
                  // Common filler words and pronouns
                  "this", "that", "what", "with", "have", "your", "from", "there", "would", "could", "about", "which",
                  "just", "like", "it's", "yeah", "don't", "going", "gonna", "you're", "thank", "then", "know", "because",
                  "they", "well", "need", "give", "take", "back", "right", "name", "alright", "when", "want", "here",
                  "make", "let's", "will", "okay", "actually", "sorry", "able", "sure", "were", "been", "does", "doing", 
                  "should", "can't", "can't", "didn't", "isn't", "that's", "i'll", "we'll", "wasn't", "they're",
                  "where", "their", "them", "these", "those", "some", "myself", "yourself", "himself", "herself",
                  // Common corporate jargon and fillers
                  "please", "account", "information", "customer", "service", "contact", "number", "email", "phone", 
                  "call", "calling", "assistance",
                  // Additional words spotted in screenshot
                  "help", "good", "time", "more", "only", "send", "still", "text", "data", "said", "today", 
                  "what's", "we're", "boost", "card", "digit", "yeah,", "you,", "here.", "know,", "right,", "yes,",
                  "alright,", "that,", "bye,", "cxo-supcall-de-escalate", "credit_debit_number", "choosing", "phone",
                  "payment", "cxo-wireless-call-issues", "i've"
                ].includes(word)
              );
              
              words.forEach(word => {
                dashboardData.wordFrequency[word] = (dashboardData.wordFrequency[word] || 0) + 1;
              });
            }
          });
        }
        
        // Track repeat callers
        const customerPhone = call.meta["Customer phone number / email address"];
        if (customerPhone && customerPhone !== "Unknown" && customerPhone !== "N/A") {
          // Create or update caller record
          if (!dashboardData.repeatCallers[customerPhone]) {
            dashboardData.repeatCallers[customerPhone] = {
              phoneNumber: customerPhone,
              calls: [],
              flagCount: {},
              firstCall: null,
              latestCall: null
            };
          }
          
          // Add call to caller's history
          const callerRecord = dashboardData.repeatCallers[customerPhone];
          callerRecord.calls.push({
            id: call.meta["Contact ID"],
            timestamp: call.meta["Initiation timestamp"],
            flags: call.flags || [],
            agent: agent
          });
          
          // Update flag counts
          if (call.flags) {
            call.flags.forEach(flag => {
              callerRecord.flagCount[flag] = (callerRecord.flagCount[flag] || 0) + 1;
            });
          }
          
          // Track first and latest call
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              if (!callerRecord.firstCall || date < new Date(callerRecord.firstCall)) {
                callerRecord.firstCall = timestamp;
              }
              if (!callerRecord.latestCall || date > new Date(callerRecord.latestCall)) {
                callerRecord.latestCall = timestamp;
              }
            }
          }
        }
        
        // Process categories
        if (call.meta["Categories"] && call.meta["Categories"] !== "N/A") {
          // Split categories string by commas
          const categoryList = call.meta["Categories"].split(',').map(cat => cat.trim());
          
          // Count each category
          categoryList.forEach(category => {
            if (category) {
              dashboardData.categories[category] = (dashboardData.categories[category] || 0) + 1;
            }
          });
        }
      });
      
      // Calculate averages
      Object.values(dashboardData.agents).forEach(agent => {
        agent.avgDuration = agent.totalCalls > 0 ? agent.totalDuration / agent.totalCalls : 0;
      });
    }
    
    // Parse duration string to minutes
    function parseDuration(durationText) {
      // Try to handle different duration formats
      if (!durationText) return 0;
      
      // Format: "HH:MM:SS"
      const timeMatch = durationText.match(/(\d+):(\d+):(\d+)/);
      if (timeMatch) {
        const hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3]);
        return hours * 60 + minutes + seconds / 60;
      }
      
      // Format: "X minutes Y seconds"
      const textMatch = durationText.match(/(\d+)\s*minutes?\s*(?:and\s*)?(?:(\d+)\s*seconds?)?/i);
      if (textMatch) {
        const minutes = parseInt(textMatch[1] || 0);
        const seconds = parseInt(textMatch[2] || 0);
        return minutes + seconds / 60;
      }
      
      // Try to parse as number
      const num = parseFloat(durationText);
      if (!isNaN(num)) return num;
      
      return 0;
    }
    
    // Refresh all dashboard elements
    function refreshDashboard() {
      if (!dashboardData.loaded) {
        dataStatus.textContent = "Please load data first";
        return;
      }
      
      updateSummaryStats();
      renderAgentPerformanceChart();
      renderFlagDistributionChart();
      renderPositiveIndicatorsChart();
      renderTimeDistributionCharts();
      renderChannelAndQueueCharts();
      renderCategoriesChart();
      updateTopAgentsTable();
      updatePositiveCallsList();
      updateRepeatCallersTable();
      updateCommonTopics();
    }
    
    // Update summary statistics
    function updateSummaryStats() {
      const totalCalls = dashboardData.calls.length;
      let flaggedCalls = 0;
      let positiveCalls = 0;
      let totalDuration = 0;
      
      dashboardData.calls.forEach(call => {
        if (call.flags && call.flags.length > 0) flaggedCalls++;
        if (call.positiveFlags && call.positiveFlags.length > 0) positiveCalls++;
        
        const durationText = call.meta["Contact duration"] || "0";
        totalDuration += parseDuration(durationText);
      });
      
      const avgDuration = totalCalls > 0 ? totalDuration / totalCalls : 0;
      
      // Update DOM
      document.getElementById('totalCalls').textContent = totalCalls;
      document.getElementById('flaggedCalls').textContent = flaggedCalls;
      document.getElementById('positiveCalls').textContent = positiveCalls;
      document.getElementById('avgDuration').textContent = avgDuration.toFixed(1) + ' min';
    }
    
    // Render the agent performance chart
    function renderAgentPerformanceChart() {
      const ctx = document.getElementById('agentPerformanceChart').getContext('2d');
      
      // Prepare data
      const agents = Object.values(dashboardData.agents)
        .sort((a, b) => b.totalCalls - a.totalCalls)
        .slice(0, 5); // Top 5 by call volume
      
      const labels = agents.map(a => a.name);
      const flaggedData = agents.map(a => a.flaggedCalls);
      const positiveData = agents.map(a => a.positiveCalls);
      const neutralData = agents.map(a => a.totalCalls - a.flaggedCalls - a.positiveCalls);
      
      // Destroy existing chart if it exists
      if (agentPerformanceChart) {
        agentPerformanceChart.destroy();
      }
      
      // Create new chart
      agentPerformanceChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Positive Calls',
              data: positiveData,
              backgroundColor: 'rgba(76, 175, 80, 0.7)',
              borderColor: 'rgba(76, 175, 80, 1)',
              borderWidth: 1
            },
            {
              label: 'Neutral Calls',
              data: neutralData,
              backgroundColor: 'rgba(158, 158, 158, 0.7)',
              borderColor: 'rgba(158, 158, 158, 1)',
              borderWidth: 1
            },
            {
              label: 'Flagged Calls',
              data: flaggedData,
              backgroundColor: 'rgba(255, 77, 77, 0.7)',
              borderColor: 'rgba(255, 77, 77, 1)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render the flag distribution chart
    function renderFlagDistributionChart() {
      const ctx = document.getElementById('flagDistributionChart').getContext('2d');
      
      // Get top flags
      const topFlags = Object.entries(dashboardData.flags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8); // Top 8 flags
      
      // Prepare data
      const labels = topFlags.map(f => f[0]);
      const data = topFlags.map(f => f[1]);
      
      // Destroy existing chart if it exists
      if (flagDistributionChart) {
        flagDistributionChart.destroy();
      }
      
      // Create new chart
      flagDistributionChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Flag Occurrences',
            data: data,
            backgroundColor: 'rgba(255, 77, 77, 0.7)',
            borderColor: 'rgba(255, 77, 77, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render the positive indicators chart
    function renderPositiveIndicatorsChart() {
      const ctx = document.getElementById('positiveIndicatorsChart').getContext('2d');
      
      // Get top positive flags
      const topPositiveFlags = Object.entries(dashboardData.positiveFlags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8); // Top 8 positive flags
      
      // Prepare data
      const labels = topPositiveFlags.map(f => f[0]);
      const data = topPositiveFlags.map(f => f[1]);
      
      // Destroy existing chart if it exists
      if (positiveIndicatorsChart) {
        positiveIndicatorsChart.destroy();
      }
      
      // Create new chart
      positiveIndicatorsChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Positive Indicator Occurrences',
            data: data,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render time distribution charts
    function renderTimeDistributionCharts() {
      // Hour distribution chart
      const hourCtx = document.getElementById('timeDistributionChart').getContext('2d');
      
      // Destroy existing chart if it exists
      if (timeDistributionChart) {
        timeDistributionChart.destroy();
      }
      
      // Create labels for hours
      const hourLabels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      // Create new chart
      timeDistributionChart = new Chart(hourCtx, {
        type: 'bar',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Calls by Hour of Day',
            data: dashboardData.hourDistribution,
            backgroundColor: 'rgba(164, 62, 201, 0.7)',
            borderColor: 'rgba(164, 62, 201, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      // Day of week distribution chart
      const dayCtx = document.getElementById('dayDistributionChart').getContext('2d');
      
      // Destroy existing chart if it exists
      if (dayDistributionChart) {
        dayDistributionChart.destroy();
      }
      
      // Create new chart
      dayDistributionChart = new Chart(dayCtx, {
        type: 'bar',
        data: {
          labels: dayNames,
          datasets: [{
            label: 'Calls by Day of Week',
            data: dashboardData.dayDistribution,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render channel and queue distribution charts
    function renderChannelAndQueueCharts() {
      // Channel distribution
      const channelCtx = document.getElementById('channelDistributionChart').getContext('2d');
      
      // Prepare data
      const channelLabels = Object.keys(dashboardData.channelDistribution);
      const channelData = Object.values(dashboardData.channelDistribution);
      
      // Destroy existing chart if it exists
      if (channelDistributionChart) {
        channelDistributionChart.destroy();
      }
      
      // Create new chart
      channelDistributionChart = new Chart(channelCtx, {
        type: 'pie',
        data: {
          labels: channelLabels,
          datasets: [{
            data: channelData,
            backgroundColor: [
              'rgba(255, 99, 132, 0.7)',
              'rgba(54, 162, 235, 0.7)',
              'rgba(255, 206, 86, 0.7)',
              'rgba(75, 192, 192, 0.7)',
              'rgba(153, 102, 255, 0.7)',
              'rgba(255, 159, 64, 0.7)'
            ],
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      // Queue distribution
      const queueCtx = document.getElementById('queueDistributionChart').getContext('2d');
      
      // Prepare data
      const queueLabels = Object.keys(dashboardData.queueDistribution);
      const queueData = Object.values(dashboardData.queueDistribution);
      
      // Destroy existing chart if it exists
      if (queueDistributionChart) {
        queueDistributionChart.destroy();
      }
      
      // Create new chart
      queueDistributionChart = new Chart(queueCtx, {
        type: 'pie',
        data: {
          labels: queueLabels,
          datasets: [{
            data: queueData,
            backgroundColor: [
              'rgba(54, 162, 235, 0.7)',
              'rgba(255, 99, 132, 0.7)',
              'rgba(255, 206, 86, 0.7)',
              'rgba(75, 192, 192, 0.7)',
              'rgba(153, 102, 255, 0.7)',
              'rgba(255, 159, 64, 0.7)'
            ],
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render categories chart
    function renderCategoriesChart() {
      const ctx = document.getElementById('categoriesChart').getContext('2d');
      const categoryDetailsContainer = document.getElementById('categoryDetails');
      
      // Get categories data
      const categories = Object.entries(dashboardData.categories)
        .sort((a, b) => b[1] - a[1]) // Sort by count descending
        .slice(0, 10); // Top 10 categories
      
      // Check if we have data
      if (categories.length === 0) {
        categoryDetailsContainer.innerHTML = '<div class="no-data-message">No categories data available</div>';
        return;
      }
      
      // Prepare chart data
      const labels = categories.map(c => c[0]);
      const counts = categories.map(c => c[1]);
      
      // Create color array - gradient from green to purple
      const colors = counts.map((_, index) => {
        const ratio = index / (counts.length - 1);
        const r = Math.round(164 + (76 - 164) * ratio);
        const g = Math.round(62 + (175 - 62) * ratio);
        const b = Math.round(201 + (80 - 201) * ratio);
        return `rgba(${r}, ${g}, ${b}, 0.7)`;
      });
      
      // Destroy existing chart if it exists
      if (categoriesChart) {
        categoriesChart.destroy();
      }
      
      // Create new chart
      categoriesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Call Count',
              data: counts,
              backgroundColor: colors,
              borderColor: colors.map(c => c.replace('0.7', '1')),
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            },
            title: {
              display: true,
              text: 'Top Call Categories',
              color: '#ccc',
              font: {
                size: 16
              }
            }
          }
        }
      });
      
      // Update category details section with table
      let detailsHtml = `
        <h3 style="font-size: 16px; margin-bottom: 10px; color: #aaa;">Category Distribution</h3>
        <table style="width: 100%;">
          <thead>
            <tr>
              <th style="text-align: left;">Category</th>
              <th style="text-align: right;">Count</th>
              <th style="text-align: right;">Percentage</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      const totalCalls = dashboardData.calls.length;
      categories.forEach(([category, count]) => {
        const percentage = (count / totalCalls * 100).toFixed(1);
        detailsHtml += `
          <tr>
            <td style="text-align: left;">${category}</td>
            <td style="text-align: right;">${count}</td>
            <td style="text-align: right;">${percentage}%</td>
          </tr>
        `;
      });
      
      detailsHtml += `
          </tbody>
        </table>
      `;
      
      categoryDetailsContainer.innerHTML = detailsHtml;
    }
    
    // Update the repeat callers table
    function updateRepeatCallersTable() {
      const tableBody = document.getElementById('repeatCallersBody');
      
      // Get callers with multiple calls
      const repeatCallers = Object.values(dashboardData.repeatCallers)
        .filter(caller => caller.calls.length > 1)
        .sort((a, b) => b.calls.length - a.calls.length);
      
      // Clear table
      tableBody.innerHTML = '';
      
      // No data case
      if (repeatCallers.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" class="no-data-message">No repeat callers found</td>';
        tableBody.appendChild(row);
        return;
      }
      
      // Add rows (limited to top 10)
      repeatCallers.slice(0, 10).forEach(caller => {
        const row = document.createElement('tr');
        
        // Get top flags for this caller
        const topFlags = Object.entries(caller.flagCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([flag, count]) => `${flag} (${count})`)
          .join(', ');
        
        // Format phone number for privacy
        const phoneDisplay = caller.phoneNumber.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
        
        row.innerHTML = `
          <td>${phoneDisplay}</td>
          <td>${caller.calls.length}</td>
          <td>${caller.latestCall ? new Date(caller.latestCall).toLocaleString() : 'Unknown'}</td>
          <td>${caller.firstCall ? new Date(caller.firstCall).toLocaleString() : 'Unknown'}</td>
          <td>${topFlags || 'None'}</td>
        `;
        
        tableBody.appendChild(row);
      });
    }
    
    // Update common topics word cloud
    function updateCommonTopics() {
      const container = document.getElementById('commonTopics');
      
      // Get top words
      const topWords = Object.entries(dashboardData.wordFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 40); // Top 40 words
      
      // Clear container
      container.innerHTML = '';
      
      // No data case
      if (topWords.length === 0) {
        const message = document.createElement('div');
        message.className = 'no-data-message';
        message.textContent = 'No word frequency data available';
        container.appendChild(message);
        return;
      }
      
      // Calculate max frequency for scaling
      const maxFrequency = topWords[0][1];
      
      // Add words as tags
      topWords.forEach(([word, count]) => {
        // Scale font size based on frequency
        const fontSize = Math.max(12, Math.min(24, 12 + (count / maxFrequency) * 12));
        const opacity = 0.5 + (count / maxFrequency) * 0.5;
        
        const wordElement = document.createElement('div');
        wordElement.style.fontSize = `${fontSize}px`;
        wordElement.style.padding = '3px 8px';
        wordElement.style.margin = '3px';
        wordElement.style.borderRadius = '10px';
        wordElement.style.background = `rgba(255, 255, 255, ${opacity * 0.1})`;
        wordElement.style.color = '#eee';
        wordElement.title = `${count} occurrences`;
        wordElement.textContent = word;
        
        container.appendChild(wordElement);
      });
    }
    
    // Update the top agents table
    function updateTopAgentsTable() {
      const tableBody = document.getElementById('topAgentsBody');
      
      // Calculate positive ratio and sort agents
      const sortedAgents = Object.values(dashboardData.agents)
        .map(agent => {
          const positiveRatio = agent.totalCalls > 0 ? 
            (agent.positiveCalls / agent.totalCalls) : 0;
          const avgScore = agent.totalCalls > 0 ? 
            (agent.positiveScore / agent.totalCalls) : 0;
            
          return {
            ...agent,
            positiveRatio,
            avgScore
          };
        })
        .sort((a, b) => b.avgScore - a.avgScore)
        .slice(0, 5); // Top 5 by positive score
      
      // Clear table
      tableBody.innerHTML = '';
      
      // No data case
      if (sortedAgents.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" class="no-data-message">No data available</td>';
        tableBody.appendChild(row);
        return;
      }
      
      // Add rows
      sortedAgents.forEach(agent => {
        const row = document.createElement('tr');
        
        row.innerHTML = `
          <td>${agent.name}</td>
          <td>${agent.totalCalls}</td>
          <td>${(agent.positiveRatio * 100).toFixed(1)}%</td>
          <td>${agent.avgScore.toFixed(2)}</td>
          <td>${agent.avgDuration.toFixed(1)} min</td>
        `;
        
        tableBody.appendChild(row);
      });
    }
    
    // Update the positive calls list
    function updatePositiveCallsList() {
      const container = document.getElementById('positiveCallsList');
      
      // Get top positive calls
      const positiveCalls = dashboardData.calls
        .filter(call => call.positiveScore > 0)
        .sort((a, b) => b.positiveScore - a.positiveScore)
        .slice(0, 5); // Top 5 positive calls
      
      // Clear container
      container.innerHTML = '';
      
      // No data case
      if (positiveCalls.length === 0) {
        const message = document.createElement('div');
        message.className = 'no-data-message';
        message.textContent = 'No positive calls available';
        container.appendChild(message);
        return;
      }
      
      // Add positive calls
      positiveCalls.forEach(call => {
        const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
        const date = call.meta["Initiation timestamp"] || "Unknown date";
        const duration = call.meta["Contact duration"] || "Unknown";
        
        const callElement = document.createElement('div');
        callElement.style.margin = '0 0 15px 0';
        callElement.style.padding = '10px';
        callElement.style.background = 'rgba(76, 175, 80, 0.05)';
        callElement.style.borderLeft = '3px solid #4caf50';
        
        callElement.innerHTML = `
          <div><strong>${agent}</strong> - ${new Date(date).toLocaleString()} - Duration: ${duration}</div>
          <div>Positive Score: <span class="positive-color">${call.positiveScore}</span></div>
          <div>
            ${call.positiveFlags.map(flag => 
              `<span style="display: inline-block; margin: 3px; padding: 2px 6px; background: rgba(76, 175, 80, 0.1); border-radius: 3px; color: #4caf50;">${flag}</span>`
            ).join('')}
          </div>
          ${call.summary ? `<div style="margin-top: 5px; font-style: italic; color: #aaa;">${call.summary}</div>` : ''}
        `;
        
        container.appendChild(callElement);
      });
    }
    
    // Automatically try to load data when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      loadDataFromParser();
    });
  </script>
</body>
</html>
