<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inspiro Analytics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="js/agentFilterManager.js"></script>
  <script src="js/repeatAnalysis.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    .corporate-header {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      padding: 15px;
      background: #1e1e1e;
      border-radius: 5px;
    }
    .dashboard-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .dashboard-card {
      background: #222;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .card-header {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .accent-color {
      color: #a43ec9;
    }
    .positive-color {
      color: #4caf50;
    }
    .negative-color {
      color: #ff4d4d;
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .stat-card {
      background: #2a2a2a;
      border-radius: 5px;
      padding: 15px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .stat-label {
      font-size: 14px;
      color: #aaa;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    th {
      background-color: #2a2a2a;
      color: #ccc;
    }
    .data-controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #222;
      border-radius: 5px;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    button {
      padding: 8px 15px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .primary-button {
      background: #a43ec9;
      border-color: #a43ec9;
    }
    button:hover {
      background: #444 !important;
    }
    .primary-button:hover {
      background: #b44dd9 !important;
      border-color: #b44dd9;
    }
    .no-data-message {
      text-align: center;
      padding: 30px;
      color: #888;
      font-style: italic;
    }

    /* Tab System Styles */
    .tab-navigation {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #333; /* Separator for tabs */
    }

    .tab-button {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #222; /* Darker, inactive tab */
      color: #aaa;
      border: none;
      border-bottom: 3px solid transparent; /* For active indicator */
      margin-right: 5px;
      transition: background-color 0.3s, color 0.3s, border-bottom 0.3s;
      font-size: 16px;
      border-top-left-radius: 5px; /* Rounded corners for tabs */
      border-top-right-radius: 5px;
    }

    .tab-button:hover {
      background-color: #333 !important; /* Consistent hover with other buttons */
      color: #fff !important;
    }

    .tab-button.active {
      background-color: #1a1a1a !important; /* Match body background for seamless look */
      color: #a43ec9 !important; /* Accent color for active tab text */
      border-bottom: 3px solid #a43ec9; /* Accent color indicator */
      font-weight: bold;
    }

    .tab-content {
      display: none;
      padding-top: 20px; /* Space between tab nav and content */
      animation: fadeIn 0.5s; /* Simple fade-in animation */
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* End Tab System Styles */
  </style>
</head>
<body>
  <div class="corporate-header">
    <h1 style="font-family: Arial, sans-serif;">
      <span style="color: #000; font-size: 42px; font-weight: 900;">inspi</span><span style="color: #a43ec9; font-size: 42px; font-weight: 900;">r</span><span style="color: #000; font-size: 42px; font-weight: 900;">o</span> <span style="font-size: 28px; font-weight: bold;">Analytics Dashboard</span>
    </h1>
    <p>Comprehensive analytics of call transcripts for enhanced customer service performance.</p>
  </div>

  <div class="data-controls">
    <button id="loadDataButton" class="primary-button">Load Data from Parser</button>
    <button id="refreshButton">Refresh Dashboard</button>
    <div id="dataStatus">No data loaded</div>
    <div style="margin-left: auto;">
        <label for="agentFilter" style="margin-right: 5px; font-size: 14px;">Filter Agents:</label>
        <select id="agentFilter" multiple style="min-width: 200px; padding: 5px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;"></select>
    </div>
  </div>

  <div class="tab-navigation">
    <button class="tab-button active" data-tab="overviewTab">üìä Overview</button>
    <button class="tab-button" data-tab="distributionTab">üìà Distribution Analysis</button>
    <button class="tab-button" data-tab="insightsTab">üë• Agent & Caller Insights</button>
    <button class="tab-button" data-tab="positiveTab">üåü Positive Performance</button>
    <button class="tab-button" data-tab="repeatCallersTab">üîÅ Repeat Callers</button>
    <button class="tab-button" data-tab="coachingTab">üß† Coaching & Follow-up</button>
    <button class="tab-button" data-tab="reportsTab">üìã Reports & Export</button>
  </div>

  <div id="overviewTab" class="tab-content active">
    <div class="dashboard-container">
      <!-- Summary Statistics -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Call Statistics Summary</span>
        </div>
        <div class="stat-grid">
          <div class="stat-card">
            <div class="stat-label">Total Calls</div>
            <div class="stat-value" id="totalCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Flagged Calls</div>
            <div class="stat-value negative-color" id="flaggedCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Positive Calls</div>
            <div class="stat-value positive-color" id="positiveCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Avg. Call Duration</div>
            <div class="stat-value" id="avgDuration">0 min</div>
          </div>
        </div>
      </div>

      <!-- Agent Performance -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üë• Agent Performance</span>
        </div>
        <div class="chart-container">
          <canvas id="agentPerformanceChart"></canvas>
        </div>
      </div>

      <!-- Flag Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üö© Flag Distribution</span>
        </div>
        <div class="chart-container">
          <canvas id="flagDistributionChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div id="distributionTab" class="tab-content">
    <div class="dashboard-container">
      <!-- Positive Indicators (Moving to Positive Tab later, placeholder for structure) -->
      <!-- This card will be moved. Keeping structure for now. -->
      <div class="dashboard-card" style="display:none;" id="positiveIndicatorsCardPlaceholder">
        <div class="card-header">
          <span>üåü Positive Indicators (Placeholder)</span>
        </div>
        <div class="chart-container">
          <canvas id="positiveIndicatorsChart"></canvas>
        </div>
      </div>

      <!-- Time Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>‚è∞ Call Time Distribution</span>
        </div>
        <div class="chart-container">
          <canvas id="timeDistributionChart"></canvas>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
          <canvas id="dayDistributionChart"></canvas>
        </div>
      </div>
      
      <!-- Channel & Queue Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üì± Channel & Queue Distribution</span>
        </div>
        <div style="display: flex; gap: 20px;">
          <div style="flex: 1;">
            <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Channels</h3>
            <div class="chart-container" style="height: 200px;">
              <canvas id="channelDistributionChart"></canvas>
            </div>
          </div>
          <div style="flex: 1;">
            <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Queues</h3>
            <div class="chart-container" style="height: 200px;">
              <canvas id="queueDistributionChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="dashboard-container">
      <!-- Categories Analysis -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Categories Analysis</span>
        </div>
        <div class="chart-container">
          <canvas id="categoriesChart"></canvas>
        </div>
        <div id="categoryDetails" style="margin-top: 15px; padding: 10px;">
          <div class="no-data-message">No categories data available</div>
        </div>
      </div>
    </div>
  </div>

  <div id="insightsTab" class="tab-content">
    <div class="dashboard-container">
      <!-- Repeat Callers Analysis - This will be moved -->
      <div class="dashboard-card" id="repeatCallersCardOriginalLocation" style="display:none;"> 
        <div class="card-header">
          <span>üîÅ Repeat Callers Analysis (Original Location - Hidden)</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Customer Phone</th>
              <th>Call Count</th>
              <th>Latest Call</th>
              <th>First Call</th>
              <th>Common Flags</th>
            </tr>
          </thead>
          <tbody id="repeatCallersBodyOriginalLocation">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- Common Topics -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üîç Common Topics</span>
        </div>
        <div id="commonTopics" style="padding: 10px; display: flex; flex-wrap: wrap; gap: 8px;">
          <div class="no-data-message">No data available</div>
        </div>
      </div>
    </div>
    
    <div class="dashboard-container">
      <!-- Top Agents Table - This will be moved -->
      <div class="dashboard-card" id="topAgentsCardOriginalLocation" style="display:none;">
        <div class="card-header">
          <span>üèÜ Top Performing Agents (Original Location - Hidden)</span>
        </div>
        <table id="topAgentsTableOriginalLocation">
          <thead>
            <tr>
              <th>Agent</th>
              <th>Total Calls</th>
              <th>Positive Ratio</th>
              <th>Avg Score</th>
              <th>Avg Duration</th>
            </tr>
          </thead>
          <tbody id="topAgentsBodyOriginalLocation">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- Recent Positive Calls (Moving to Positive Tab later, placeholder for structure)-->
      <div class="dashboard-card" style="display:none;" id="recentPositiveCallsPlaceholder">
        <div class="card-header">
          <span>‚úÖ Recent Positive Calls (Placeholder)</span>
        </div>
        <div id="positiveCallsList">
          <div class="no-data-message">No data available</div>
        </div>
      </div>
    </div>
  </div>

  <div id="positiveTab" class="tab-content">
    <div class="dashboard-container">
        <!-- Positive Indicators -->
        <div class="dashboard-card" id="positiveIndicatorsCardActual">
            <div class="card-header">
                <span>üåü Positive Indicators</span>
            </div>
            <div class="chart-container">
                <canvas id="positiveIndicatorsChartActual"></canvas> 
            </div>
        </div>
        <!-- Recent Positive Calls -->
        <div class="dashboard-card" id="recentPositiveCallsActual">
            <div class="card-header">
                <span>‚úÖ Recent Positive Calls</span>
            </div>
            <div id="positiveCallsListActual" style="max-height: 400px; overflow-y: auto;"> 
                <div class="no-data-message">No data available</div>
            </div>
        </div>
        <!-- Top Performing Agents - Moved Here -->
        <div class="dashboard-card" id="topAgentsCardMoved">
          <div class="card-header">
            <span>üèÜ Top Performing Agents</span>
          </div>
          <table id="topAgentsTable">
            <thead>
              <tr>
                <th>Agent</th>
                <th>Total Calls</th>
                <th>Positive Ratio</th>
                <th>Avg Score</th>
                <th>Avg Duration</th>
              </tr>
            </thead>
            <tbody id="topAgentsBody">
              <tr>
                <td colspan="5" class="no-data-message">No data available</td>
              </tr>
            </tbody>
          </table>
        </div>
    </div>
  </div> <!-- End of positiveTab -->

  <!-- New Tab: Repeat Caller Analytics -->
  <div id="repeatCallersTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üîÅ Repeat Callers Analysis</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Customer Phone</th>
              <th>Call Count</th>
              <th>Latest Call</th>
              <th>First Call</th>
              <th>Common Flags</th>
            </tr>
          </thead>
          <tbody id="repeatCallersBody">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <!-- Placeholders for future content -->
    <div class="dashboard-container" style="margin-top: 20px;">
        <div class="dashboard-card">
            <div class="card-header">
                <span>üìä Callback Timing Charts</span>
            </div>
            <div id="repeatCallersTimingCharts">
                <!-- Content will be rendered by js/repeatAnalysis.js -->
            </div>
        </div>
        <div class="dashboard-card">
            <div class="card-header">
                <span>üß† Agent-Specific Insights (Repeat Callers)</span>
            </div>
            <div id="repeatCallersAgentInsights">
                <!-- Content will be rendered by js/repeatAnalysis.js -->
            </div>
        </div>
    </div>
  </div> <!-- End of repeatCallersTab -->

  <!-- New Tab: Coaching & Follow-up -->
  <div id="coachingTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üß† Coaching & Follow-up</span>
        </div>
        <div style="padding: 20px;">
          <p>Coaching plans, follow-up actions, and agent development tools will be available here in a future update.</p>
          <p><em>Stay tuned!</em></p>
        </div>
      </div>
    </div>
  </div> <!-- End of coachingTab -->

  <!-- New Tab: Reports & Export -->
  <div id="reportsTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìã Reports & Export</span>
        </div>
        <div style="padding: 20px;">
          <p>Advanced report generation, data export configurations, and distribution options will be available here.</p>
          <p><em>Coming soon!</em></p>
        </div>
      </div>
    </div>
  </div> <!-- End of reportsTab -->

  <script>
    // Dashboard state
    let dashboardData = {
      calls: [],
      filteredCalls: [],
      agents: {},
      agentColors: {},
      flags: {},
      positiveFlags: {},
      hourDistribution: new Array(24).fill(0),
      dayDistribution: new Array(7).fill(0),
      channelDistribution: {},
      queueDistribution: {},
      wordFrequency: {},
      repeatCallers: {},
      categories: {},
      loaded: false
    };
    
    // DOM elements
    const loadDataButton = document.getElementById('loadDataButton');
    const refreshButton = document.getElementById('refreshButton');
    const dataStatus = document.getElementById('dataStatus');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    const agentFilterElement = document.getElementById('agentFilter');
    
    // Chart objects
    let agentPerformanceChart = null;
    let flagDistributionChart = null;
    let positiveIndicatorsChartActual = null;
    let timeDistributionChart = null;
    let dayDistributionChart = null;
    let channelDistributionChart = null;
    let queueDistributionChart = null;
    let categoriesChart = null;
    
    // Constants
    const DAY_NAMES = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const COLOR_POOL = [
        'rgba(164, 62, 201, 0.8)', 'rgba(76, 175, 80, 0.8)', 'rgba(255, 77, 77, 0.8)', 
        'rgba(33, 150, 243, 0.8)', 'rgba(255, 152, 0, 0.8)', 'rgba(0, 150, 136, 0.8)',
        'rgba(233, 30, 99, 0.8)', 'rgba(139, 195, 74, 0.8)', 'rgba(255, 235, 59, 0.8)',
        'rgba(121, 85, 72, 0.8)', 'rgba(158, 158, 158, 0.8)', 'rgba(96, 125, 139, 0.8)'
    ];
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      loadDataButton.addEventListener('click', loadDataFromParser);
      refreshButton.addEventListener('click', refreshDashboard);

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          button.classList.add('active');
          const activeTabId = button.dataset.tab;
          document.getElementById(activeTabId).classList.add('active');
          
          // Render or update content for the newly active tab
          if (dashboardData.loaded) {
            renderActiveTabContent(activeTabId);
          }
        });
      });

      // Automatically try to load data and activate the first tab
      loadDataFromParser().then(() => {
        if (dashboardData.loaded) {
          const uniqueAgentNames = Object.keys(dashboardData.agents).sort();
          initializeAgentFilterDropdown(uniqueAgentNames, handleAgentFilterChange);
          handleAgentFilterChange(getSelectedAgentsFromFilter());
        }
        if (tabButtons.length > 0 && !document.querySelector('.tab-button.active')) {
            tabButtons[0].click(); // Activate the first tab if none is active
        }
      }); 
    });
    
    // New function to handle rendering content of the active tab
    function renderActiveTabContent(activeTabId) {
        if (!dashboardData.loaded || !dashboardData.filteredCalls || dashboardData.filteredCalls.length === 0) {
            console.log("No filtered data to render for tab:", activeTabId);
            if (activeTabId === 'overviewTab') {
                if (agentPerformanceChart) agentPerformanceChart.destroy();
                if (flagDistributionChart) flagDistributionChart.destroy();
                agentPerformanceChart = null;
                flagDistributionChart = null;
            } else if (activeTabId === 'distributionTab') {
                if (timeDistributionChart) timeDistributionChart.destroy();
                if (dayDistributionChart) dayDistributionChart.destroy();
                if (channelDistributionChart) channelDistributionChart.destroy();
                if (queueDistributionChart) queueDistributionChart.destroy();
                if (categoriesChart) categoriesChart.destroy();
                timeDistributionChart = null;
                dayDistributionChart = null;
                channelDistributionChart = null;
                queueDistributionChart = null;
                categoriesChart = null;
            } else if (activeTabId === 'positiveTab') {
                if (positiveIndicatorsChartActual) positiveIndicatorsChartActual.destroy();
                positiveIndicatorsChartActual = null;
                document.getElementById('positiveCallsListActual').innerHTML = '<div class="no-data-message">No positive performance data for current filter</div>';
                document.getElementById('topAgentsBody').innerHTML = '<tr><td colspan="5" class="no-data-message">No agent data for current filter</td></tr>';
            } else if (activeTabId === 'repeatCallersTab') {
                updateRepeatCallersTabContent(dashboardData.filteredCalls);
            } else if (activeTabId === 'insightsTab') {
                document.getElementById('commonTopics').innerHTML = '<div class="no-data-message">No common topics for current filter</div>';
            }
            return;
        }

        if (activeTabId === 'overviewTab') {
            renderAgentPerformanceChart();
            renderFlagDistributionChart();
        } else if (activeTabId === 'distributionTab') {
            renderTimeDistributionCharts();
            renderChannelAndQueueCharts();
            renderCategoriesChart();
        } else if (activeTabId === 'insightsTab') {
            updateCommonTopics();
        } else if (activeTabId === 'positiveTab') {
            renderPositiveIndicatorsChartActual(); 
            updatePositiveCallsListActual(); 
            updateTopAgentsTable();
        } else if (activeTabId === 'repeatCallersTab') {
            updateRepeatCallersTabContent(dashboardData.filteredCalls);
        } else if (activeTabId === 'coachingTab') {
            // Placeholder: No dynamic content to render yet
        } else if (activeTabId === 'reportsTab') {
            // Placeholder: No dynamic content to render yet
        }
    }
    
    // Load data from localStorage
    async function loadDataFromParser() {
      dataStatus.textContent = "Attempting to load data...";
      dashboardData.loaded = false; 
      dashboardData.calls = [];
      dashboardData.filteredCalls = [];
      try {
        // Try to get data from localStorage
        const storedData = localStorage.getItem('inspiroCallData');
        
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            if (Array.isArray(parsedData) && parsedData.length > 0) {
              dashboardData.calls = parsedData;
              
              // Populate agentColors based on ALL agents in the dataset
              const allAgentNamesInDataset = [...new Set(dashboardData.calls.map(call => call.meta["Agent"] || call.meta["Agent name"] || "Unknown"))].sort();
              allAgentNamesInDataset.forEach((name, index) => {
                  if (name !== "Unknown") { // Optionally exclude "Unknown" from having a dedicated color
                    dashboardData.agentColors[name] = COLOR_POOL[index % COLOR_POOL.length];
                  }
              });
              // console.log("[Debug] Populated agentColors:", JSON.parse(JSON.stringify(dashboardData.agentColors)));

              processData();
              dataStatus.textContent = `‚úÖ Loaded ${dashboardData.calls.length} calls`;
              dashboardData.loaded = true;
              
              const uniqueAgentNames = Object.keys(dashboardData.agents).sort();
              initializeAgentFilterDropdown(uniqueAgentNames, handleAgentFilterChange);
              handleAgentFilterChange(getSelectedAgentsFromFilter());
              return;
            }
          } catch (parseError) {
            console.error("Error parsing stored data:", parseError);
          }
        }
        
        dataStatus.textContent = "No data found. Please parse calls in the main tool first.";
      } catch (error) {
        dataStatus.textContent = `‚ùå Error: ${error.message}`;
        console.error(error);
      }
    }
    
    // Process the raw call data into usable statistics
    function processData() {
      // Reset processed data
      dashboardData.agents = {};
      dashboardData.flags = {};
      dashboardData.positiveFlags = {};
      dashboardData.hourDistribution = new Array(24).fill(0);
      dashboardData.dayDistribution = new Array(7).fill(0);
      dashboardData.channelDistribution = {};
      dashboardData.queueDistribution = {};
      dashboardData.wordFrequency = {};
      dashboardData.repeatCallers = {};
      dashboardData.categories = {};
      
      // Determine selected agents for filtering
      const selectedAgents = getSelectedAgentsFromFilter();
      const isFiltering = selectedAgents.length > 0 && !selectedAgents.includes('all');

      dashboardData.filteredCalls = dashboardData.calls.filter(call => {
        if (!isFiltering) return true; // No filter applied or "all" selected
        const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
        return selectedAgents.includes(agent);
      });

      // Process each call from FILTERED calls for dashboard display
      dashboardData.filteredCalls.forEach(call => {
        // Agent data (still populate dashboardData.agents from ALL calls for the filter dropdown,
        // but subsequent metrics are based on filteredCalls)
        const agentName = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
        if (!dashboardData.agents[agentName]) {
          dashboardData.agents[agentName] = {
            name: agentName,
            totalCalls: 0, // This will be total in filtered set
            flaggedCalls: 0,
            positiveCalls: 0,
            positiveScore: 0,
            avgDuration: 0,
            totalDuration: 0,
          };
        }
        
        // Increment agent stats
        const agentData = dashboardData.agents[agentName];
        agentData.totalCalls++;
        
        if (call.flags && call.flags.length > 0) {
          agentData.flaggedCalls++;
        }
        
        if (call.positiveFlags && call.positiveFlags.length > 0) {
          agentData.positiveCalls++;
        }
        
        // Track positive score
        agentData.positiveScore += (call.positiveScore || 0);
        
        // Track call duration
        const durationText = call.meta["Contact duration"] || "0";
        const durationMinutes = parseDuration(durationText);
        agentData.totalDuration += durationMinutes;
        
        // Track flags
        if (call.flags) {
          call.flags.forEach(flag => {
            dashboardData.flags[flag] = (dashboardData.flags[flag] || 0) + 1;
          });
        }
        
        // Track positive flags
        if (call.positiveFlags) {
          call.positiveFlags.forEach(flag => {
            dashboardData.positiveFlags[flag] = (dashboardData.positiveFlags[flag] || 0) + 1;
          });
        }
        
        // Track time distribution
        try {
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              // Hour distribution
              const hour = date.getHours();
              dashboardData.hourDistribution[hour]++;
              
              // Day of week distribution
              const day = date.getDay();
              dashboardData.dayDistribution[day]++;
            }
          }
        } catch (error) {
          console.error("Error processing timestamp:", error);
        }
        
        // Track channel and queue
        const channel = call.meta["Channel"] || "Unknown";
        dashboardData.channelDistribution[channel] = (dashboardData.channelDistribution[channel] || 0) + 1;
        
        const queue = call.meta["Queue"] || "Unknown";
        dashboardData.queueDistribution[queue] = (dashboardData.queueDistribution[queue] || 0) + 1;
        
        // Track word frequency in transcripts
        if (call.transcript && call.transcript.length > 0) {
          call.transcript.forEach(entry => {
            if (entry.text) {
              const text = entry.text.toLowerCase();
              const words = text.split(/\s+/).filter(word => 
                word.length > 3 && 
                ![
                  // Common filler words and pronouns
                  "this", "that", "what", "with", "have", "your", "from", "there", "would", "could", "about", "which",
                  "just", "like", "it's", "yeah", "don't", "going", "gonna", "you're", "thank", "then", "know", "because",
                  "they", "well", "need", "give", "take", "back", "right", "name", "alright", "when", "want", "here",
                  "make", "let's", "will", "okay", "actually", "sorry", "able", "sure", "were", "been", "does", "doing", 
                  "should", "can't", "can't", "didn't", "isn't", "that's", "i'll", "we'll", "wasn't", "they're",
                  "where", "their", "them", "these", "those", "some", "myself", "yourself", "himself", "herself",
                  // Common corporate jargon and fillers
                  "please", "account", "information", "customer", "service", "contact", "number", "email", "phone", 
                  "call", "calling", "assistance",
                  // Additional words spotted in screenshot
                  "help", "good", "time", "more", "only", "send", "still", "text", "data", "said", "today", 
                  "what's", "we're", "boost", "card", "digit", "yeah,", "you,", "here.", "know,", "right,", "yes,",
                  "alright,", "that,", "bye,", "cxo-supcall-de-escalate", "credit_debit_number", "choosing", "phone",
                  "payment", "cxo-wireless-call-issues", "i've"
                ].includes(word)
              );
              
              words.forEach(word => {
                dashboardData.wordFrequency[word] = (dashboardData.wordFrequency[word] || 0) + 1;
              });
            }
          });
        }
        
        // Track repeat callers
        const customerPhone = call.meta["Customer phone number / email address"];
        if (customerPhone && customerPhone !== "Unknown" && customerPhone !== "N/A") {
          // Create or update caller record
          if (!dashboardData.repeatCallers[customerPhone]) {
            dashboardData.repeatCallers[customerPhone] = {
              phoneNumber: customerPhone,
              calls: [],
              flagCount: {},
              firstCall: null,
              latestCall: null
            };
          }
          
          // Add call to caller's history
          const callerRecord = dashboardData.repeatCallers[customerPhone];
          callerRecord.calls.push({
            id: call.meta["Contact ID"],
            timestamp: call.meta["Initiation timestamp"],
            flags: call.flags || [],
            agent: agentName
          });
          
          // Update flag counts
          if (call.flags) {
            call.flags.forEach(flag => {
              callerRecord.flagCount[flag] = (callerRecord.flagCount[flag] || 0) + 1;
            });
          }
          
          // Track first and latest call
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              if (!callerRecord.firstCall || date < new Date(callerRecord.firstCall)) {
                callerRecord.firstCall = timestamp;
              }
              if (!callerRecord.latestCall || date > new Date(callerRecord.latestCall)) {
                callerRecord.latestCall = timestamp;
              }
            }
          }
        }
        
        // Process categories
        if (call.meta["Categories"] && call.meta["Categories"] !== "N/A") {
          // Split categories string by commas
          const categoryList = call.meta["Categories"].split(',').map(cat => cat.trim());
          
          // Count each category
          categoryList.forEach(category => {
            if (category) {
              dashboardData.categories[category] = (dashboardData.categories[category] || 0) + 1;
            }
          });
        }
      });
      
      // Calculate averages for agents based on filtered calls
      Object.values(dashboardData.agents).forEach(agent => {
        agent.avgDuration = agent.totalCalls > 0 ? agent.totalDuration / agent.totalCalls : 0;
      });
    }
    
    // Parse duration string to minutes
    function parseDuration(durationText) {
      // Try to handle different duration formats
      if (!durationText) return 0;
      
      // Format: "HH:MM:SS"
      const timeMatch = durationText.match(/(\d+):(\d+):(\d+)/);
      if (timeMatch) {
        const hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3]);
        return hours * 60 + minutes + seconds / 60;
      }
      
      // Format: "X minutes Y seconds"
      const textMatch = durationText.match(/(\d+)\s*minutes?\s*(?:and\s*)?(?:(\d+)\s*seconds?)?/i);
      if (textMatch) {
        const minutes = parseInt(textMatch[1] || 0);
        const seconds = parseInt(textMatch[2] || 0);
        return minutes + seconds / 60;
      }
      
      // Try to parse as number
      const num = parseFloat(durationText);
      if (!isNaN(num)) return num;
      
      return 0;
    }
    
    // Refresh all dashboard elements
    function refreshDashboard() {
      if (!dashboardData.calls || dashboardData.calls.length === 0) { 
        dataStatus.textContent = "No data loaded to refresh.";
        dashboardData.loaded = false; 
        clearDashboardElements();
        return;
      }

      dataStatus.textContent = "üîÑ Re-processing and refreshing dashboard with filter...";
      processData();
      dashboardData.loaded = true; 
      
      if (dashboardData.filteredCalls.length === 0 && (getSelectedAgentsFromFilter().length > 0 && !getSelectedAgentsFromFilter().includes('all'))) {
        dataStatus.textContent = `‚ö†Ô∏è No calls match the current agent filter. Loaded ${dashboardData.calls.length} total calls.`;
        clearDashboardElements();
        const activeButtonNoData = document.querySelector('.tab-button.active');
        if (activeButtonNoData) {
            renderActiveTabContent(activeButtonNoData.dataset.tab);
        } else if (tabButtons.length > 0) {
            tabButtons[0].click();
        }
        return;
      }
      
      updateSummaryStats();

      const activeButton = document.querySelector('.tab-button.active');
      if (activeButton) {
          renderActiveTabContent(activeButton.dataset.tab);
      } else if (tabButtons.length > 0) {
          tabButtons[0].click(); 
      }
      dataStatus.textContent = `‚úÖ Dashboard refreshed. Displaying ${dashboardData.filteredCalls.length} of ${dashboardData.calls.length} calls based on filter.`;
    }
    
    // New function to clear dashboard elements
    function clearDashboardElements() {
        // Clear summary stats
        document.getElementById('totalCalls').textContent = '0';
        document.getElementById('flaggedCalls').textContent = '0';
        document.getElementById('positiveCalls').textContent = '0';
        document.getElementById('avgDuration').textContent = '0 min';

        // Clear charts by destroying them if they exist
        if (agentPerformanceChart) agentPerformanceChart.destroy();
        if (flagDistributionChart) flagDistributionChart.destroy();
        if (positiveIndicatorsChartActual) positiveIndicatorsChartActual.destroy();
        if (timeDistributionChart) timeDistributionChart.destroy();
        if (dayDistributionChart) dayDistributionChart.destroy();
        if (channelDistributionChart) channelDistributionChart.destroy();
        if (queueDistributionChart) queueDistributionChart.destroy();
        if (categoriesChart) categoriesChart.destroy();
        // Re-initialize chart variables to null
        agentPerformanceChart = flagDistributionChart = positiveIndicatorsChartActual = timeDistributionChart = null;
        dayDistributionChart = channelDistributionChart = queueDistributionChart = categoriesChart = null;

        // Clear tables and lists
        const noDataMsg = '<td colspan="5" class="no-data-message">No data available</td>';
        const originalRepeatCallersBody = document.getElementById('repeatCallersBodyOriginalLocation');
        if (originalRepeatCallersBody) originalRepeatCallersBody.innerHTML = `<tr>${noDataMsg}</tr>`;
        document.getElementById('repeatCallersBody').innerHTML = `<tr>${noDataMsg}</tr>`;
        
        document.getElementById('commonTopics').innerHTML = '<div class="no-data-message">No data available</div>';
        document.getElementById('categoryDetails').innerHTML = '<div class="no-data-message">No categories data available</div>';
        
        const originalTopAgentsBody = document.getElementById('topAgentsBodyOriginalLocation');
        if (originalTopAgentsBody) originalTopAgentsBody.innerHTML = `<tr>${noDataMsg}</tr>`;
        document.getElementById('topAgentsBody').innerHTML = `<tr>${noDataMsg}</tr>`;

        document.getElementById('positiveCallsListActual').innerHTML = '<div class="no-data-message">No data available</div>';

        // You might want to visually clear canvas elements too, e.g., by drawing a "No Data" message
        // For simplicity, destroying the chart instance usually suffices as Chart.js might clear it.
    }
    
    // Update summary statistics
    function updateSummaryStats() {
      const totalCalls = dashboardData.filteredCalls.length;
      let flaggedCalls = 0;
      let positiveCalls = 0;
      let totalDuration = 0;
      
      dashboardData.filteredCalls.forEach(call => {
        if (call.flags && call.flags.length > 0) flaggedCalls++;
        if (call.positiveFlags && call.positiveFlags.length > 0) positiveCalls++;
        
        const durationText = call.meta["Contact duration"] || "0";
        totalDuration += parseDuration(durationText);
      });
      
      const avgDuration = totalCalls > 0 ? totalDuration / totalCalls : 0;
      
      // Update DOM
      document.getElementById('totalCalls').textContent = totalCalls;
      document.getElementById('flaggedCalls').textContent = flaggedCalls;
      document.getElementById('positiveCalls').textContent = positiveCalls;
      document.getElementById('avgDuration').textContent = avgDuration.toFixed(1) + ' min';
    }
    
    // Render the agent performance chart
    function renderAgentPerformanceChart() {
      const ctx = document.getElementById('agentPerformanceChart').getContext('2d');
      
      // Rebuild agent stats based *only* on filteredCalls for this chart
      const agentsInFilteredSet = {};
      dashboardData.filteredCalls.forEach(call => {
          const agentName = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
          if (!agentsInFilteredSet[agentName]) {
              agentsInFilteredSet[agentName] = { name: agentName, totalCalls: 0, flaggedCalls: 0, positiveCalls: 0 };
          }
          agentsInFilteredSet[agentName].totalCalls++;
          if (call.flags && call.flags.length > 0) agentsInFilteredSet[agentName].flaggedCalls++;
          if (call.positiveFlags && call.positiveFlags.length > 0) agentsInFilteredSet[agentName].positiveCalls++;
      });
      
      const agents = Object.values(agentsInFilteredSet)
        .sort((a, b) => b.totalCalls - a.totalCalls)
        .slice(0, 10); // Top 10 agents in the current filtered view
      
      // Destroy existing chart if it exists
      if (agentPerformanceChart) {
        agentPerformanceChart.destroy();
      }
      
      // Create new chart
      agentPerformanceChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: agents.map(a => a.name),
          datasets: [
            {
              label: 'Positive Calls',
              data: agents.map(a => a.positiveCalls),
              backgroundColor: agents.map((a, index) => dashboardData.agentColors[a.name] ? dashboardData.agentColors[a.name].replace('0.8', '0.6') : COLOR_POOL[(index + COLOR_POOL.length -1) % COLOR_POOL.length].replace('0.8', '0.6')),
              borderColor: agents.map((a, index) => dashboardData.agentColors[a.name] || COLOR_POOL[(index + COLOR_POOL.length -1) % COLOR_POOL.length]),
              borderWidth: 1
            },
            {
              label: 'Neutral Calls',
              data: agents.map(a => a.totalCalls - a.flaggedCalls - a.positiveCalls),
              backgroundColor: agents.map((a, index) => dashboardData.agentColors[a.name] ? dashboardData.agentColors[a.name].replace('0.8', '0.4') : COLOR_POOL[index % COLOR_POOL.length].replace('0.8', '0.4')),
              borderColor: agents.map((a, index) => dashboardData.agentColors[a.name] || COLOR_POOL[index % COLOR_POOL.length]),
              borderWidth: 1
            },
            {
              label: 'Flagged Calls',
              data: agents.map(a => a.flaggedCalls),
              backgroundColor: agents.map((a, index) => dashboardData.agentColors[a.name] ? dashboardData.agentColors[a.name].replace('0.8', '0.9') : COLOR_POOL[(index + 1) % COLOR_POOL.length].replace('0.8','0.9')),
              borderColor: agents.map((a, index) => dashboardData.agentColors[a.name] || COLOR_POOL[(index + 1) % COLOR_POOL.length]),
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render the flag distribution chart
    function renderFlagDistributionChart() {
      const ctx = document.getElementById('flagDistributionChart').getContext('2d');
      
      const localFlags = {};
      dashboardData.filteredCalls.forEach(call => {
          if (call.flags) {
              call.flags.forEach(flag => {
                  localFlags[flag] = (localFlags[flag] || 0) + 1;
              });
          }
      });
      
      const topFlags = Object.entries(localFlags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8); // Top 8 flags
      
      // Destroy existing chart if it exists
      if (flagDistributionChart) {
        flagDistributionChart.destroy();
      }
      
      // Create new chart
      flagDistributionChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: topFlags.map(f => f[0]),
          datasets: [{
            label: 'Flag Occurrences',
            data: topFlags.map(f => f[1]),
            backgroundColor: 'rgba(255, 77, 77, 0.7)',
            borderColor: 'rgba(255, 77, 77, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render time distribution charts
    function renderTimeDistributionCharts() {
      const localHourDistribution = new Array(24).fill(0);
      const localDayDistribution = new Array(7).fill(0);

      dashboardData.filteredCalls.forEach(call => {
          try {
            const timestamp = call.meta["Initiation timestamp"];
            if (timestamp) {
              const date = new Date(timestamp);
              if (!isNaN(date.getTime())) {
                localHourDistribution[date.getHours()]++;
                localDayDistribution[date.getDay()]++;
              }
            }
          } catch (error) {
            console.error("Error processing timestamp for filtered time charts:", error);
          }
      });

      // Hour distribution chart
      const hourCanvas = document.getElementById('timeDistributionChart');
      if (!hourCanvas) {
        console.warn("Hour distribution chart canvas not found");
        return;
      }
      const hourCtx = hourCanvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (timeDistributionChart) {
        timeDistributionChart.destroy();
      }
      
      // Create labels for hours
      const hourLabels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      // Create new chart
      timeDistributionChart = new Chart(hourCtx, {
        type: 'bar',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Calls by Hour of Day',
            data: localHourDistribution,
            backgroundColor: 'rgba(164, 62, 201, 0.7)',
            borderColor: 'rgba(164, 62, 201, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      // Day of week distribution chart
      const dayCanvas = document.getElementById('dayDistributionChart');
      if (!dayCanvas) {
        console.warn("Day distribution chart canvas not found");
        return;
      }
      const dayCtx = dayCanvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (dayDistributionChart) {
        dayDistributionChart.destroy();
      }
      
      // Create new chart
      dayDistributionChart = new Chart(dayCtx, {
        type: 'bar',
        data: {
          labels: DAY_NAMES,
          datasets: [{
            label: 'Calls by Day of Week',
            data: localDayDistribution,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render channel and queue distribution charts
    function renderChannelAndQueueCharts() {
      const localChannelDistribution = {};
      const localQueueDistribution = {};

      dashboardData.filteredCalls.forEach(call => {
          const channel = call.meta["Channel"] || "Unknown";
          localChannelDistribution[channel] = (localChannelDistribution[channel] || 0) + 1;
          
          const queue = call.meta["Queue"] || "Unknown";
          localQueueDistribution[queue] = (localQueueDistribution[queue] || 0) + 1;
      });

      // Define a broader color palette for these charts if needed, or use the global COLOR_POOL
      const pieChartColors = [
        'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
        'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
        'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)'
      ];

      // Channel distribution
      const channelCanvas = document.getElementById('channelDistributionChart');
      if (!channelCanvas) {
        console.warn("Channel distribution chart canvas not found");
        return;
      }
      const channelCtx = channelCanvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (channelDistributionChart) {
        channelDistributionChart.destroy();
      }
      
      // Create new chart
      channelDistributionChart = new Chart(channelCtx, {
        type: 'pie',
        data: {
          labels: Object.keys(localChannelDistribution),
          datasets: [{
            data: Object.values(localChannelDistribution),
            backgroundColor: pieChartColors,
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      // Queue distribution
      const queueCanvas = document.getElementById('queueDistributionChart');
      if (!queueCanvas) {
        console.warn("Queue distribution chart canvas not found");
        return;
      }
      const queueCtx = queueCanvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (queueDistributionChart) {
        queueDistributionChart.destroy();
      }
      
      // Create new chart
      queueDistributionChart = new Chart(queueCtx, {
        type: 'pie',
        data: {
          labels: Object.keys(localQueueDistribution),
          datasets: [{
            data: Object.values(localQueueDistribution),
            backgroundColor: pieChartColors.slice().reverse(),
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render categories chart
    function renderCategoriesChart() {
      const canvasElement = document.getElementById('categoriesChart');
      if (!canvasElement) {
        console.warn("Categories chart canvas not found");
        return;
      }
      const ctx = canvasElement.getContext('2d');
      const categoryDetailsContainer = document.getElementById('categoryDetails');
      
      const localCategories = {};
      dashboardData.filteredCalls.forEach(call => {
          if (call.meta["Categories"] && call.meta["Categories"] !== "N/A") {
            const categoryList = call.meta["Categories"].split(',').map(cat => cat.trim());
            categoryList.forEach(category => {
              if (category) {
                localCategories[category] = (localCategories[category] || 0) + 1;
              }
            });
          }
      });
      
      const categories = Object.entries(localCategories)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      if (categories.length === 0) {
        if (categoriesChart) categoriesChart.destroy();
        categoriesChart = null;
        categoryDetailsContainer.innerHTML = '<div class="no-data-message">No categories data available for current filter</div>';
        return;
      }
      
      const counts = categories.map(c => c[1]);
      
      // Create color array - using a slice of COLOR_POOL for variety
      const categoryColors = COLOR_POOL.slice(0, Math.min(counts.length, COLOR_POOL.length)).map(c => c.replace('0.8', '0.7'));
      
      // Destroy existing chart if it exists
      if (categoriesChart) {
        categoriesChart.destroy();
      }
      
      // Create new chart
      categoriesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: categories.map(c => c[0]),
          datasets: [
            {
              label: 'Call Count',
              data: counts,
              backgroundColor: categoryColors,
              borderColor: categoryColors.map(c => c.replace('0.7', '1')),
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            },
            title: {
              display: true,
              text: 'Top Call Categories',
              color: '#ccc',
              font: {
                size: 16
              }
            }
          }
        }
      });
      
      // Update category details section with table
      let detailsHtml = `
        <h3 style="font-size: 16px; margin-bottom: 10px; color: #aaa;">Category Distribution</h3>
        <table style="width: 100%;">
          <thead>
            <tr>
              <th style="text-align: left;">Category</th>
              <th style="text-align: right;">Count</th>
              <th style="text-align: right;">Percentage</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      const totalCalls = dashboardData.filteredCalls.length;
      categories.forEach(([category, count]) => {
        const percentage = (count / totalCalls * 100).toFixed(1);
        detailsHtml += `
          <tr>
            <td style="text-align: left;">${category}</td>
            <td style="text-align: right;">${count}</td>
            <td style="text-align: right;">${percentage}%</td>
          </tr>
        `;
      });
      
      detailsHtml += `
          </tbody>
        </table>
      `;
      
      categoryDetailsContainer.innerHTML = detailsHtml;
    }
    
    // Update common topics word cloud
    function updateCommonTopics() {
      const container = document.getElementById('commonTopics');
      
      const localWordFrequency = {};
      dashboardData.filteredCalls.forEach(call => {
          if (call.transcript && call.transcript.length > 0) {
              call.transcript.forEach(entry => {
                  if (entry.text) {
                      const text = entry.text.toLowerCase();
                      const words = text.split(/\s+/).filter(word => 
                          word.length > 3 && 
                          ![
                            "this", "that", "what", "with", "have", "your", "from", "there", "would", "could", "about", "which",
                            "just", "like", "it's", "yeah", "don't", "going", "gonna", "you're", "thank", "then", "know", "because",
                            "they", "well", "need", "give", "take", "back", "right", "name", "alright", "when", "want", "here",
                            "make", "let's", "will", "okay", "actually", "sorry", "able", "sure", "were", "been", "does", "doing", 
                            "should", "can't", "can't", "didn't", "isn't", "that's", "i'll", "we'll", "wasn't", "they're",
                            "where", "their", "them", "these", "those", "some", "myself", "yourself", "himself", "herself",
                            "please", "account", "information", "customer", "service", "contact", "number", "email", "phone", 
                            "call", "calling", "assistance",
                            "help", "good", "time", "more", "only", "send", "still", "text", "data", "said", "today", 
                            "what's", "we're", "boost", "card", "digit", "yeah,", "you,", "here.", "know,", "right,", "yes,",
                            "alright,", "that,", "bye,", "cxo-supcall-de-escalate", "credit_debit_number", "choosing", "phone",
                            "payment", "cxo-wireless-call-issues", "i've"
                          ].includes(word)
                      );
                      words.forEach(word => {
                          localWordFrequency[word] = (localWordFrequency[word] || 0) + 1;
                      });
                  }
              });
          }
      });

      const topWords = Object.entries(localWordFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 40); // Top 40 words
      
      // Clear container
      container.innerHTML = '';
      
      // No data case
      if (topWords.length === 0) {
        const message = document.createElement('div');
        message.className = 'no-data-message';
        message.textContent = 'No word frequency data available';
        container.appendChild(message);
        return;
      }
      
      // Calculate max frequency for scaling
      const maxFrequency = topWords[0][1];
      
      // Add words as tags
      topWords.forEach(([word, count]) => {
        // Scale font size based on frequency
        const fontSize = Math.max(12, Math.min(24, 12 + (count / maxFrequency) * 12));
        const opacity = 0.5 + (count / maxFrequency) * 0.5;
        
        const wordElement = document.createElement('div');
        wordElement.style.fontSize = `${fontSize}px`;
        wordElement.style.padding = '3px 8px';
        wordElement.style.margin = '3px';
        wordElement.style.borderRadius = '10px';
        wordElement.style.background = `rgba(255, 255, 255, ${opacity * 0.1})`;
        wordElement.style.color = '#eee';
        wordElement.title = `${count} occurrences`;
        wordElement.textContent = word;
        
        container.appendChild(wordElement);
      });
    }
    
    // Update the top agents table
    function updateTopAgentsTable() {
      const tableBody = document.getElementById('topAgentsBody');
      if(!tableBody) {
        console.warn("Top agents table body not found. Original or new.");
        return;
      }
      // Calculate agent stats based on filteredCalls
      const agentsInFilteredSetForTable = {};
       dashboardData.filteredCalls.forEach(call => {
          const agentName = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
          if (!agentsInFilteredSetForTable[agentName]) {
              agentsInFilteredSetForTable[agentName] = { 
                  name: agentName, totalCalls: 0, positiveCalls: 0, positiveScore: 0, totalDuration: 0 
              };
          }
          const agentData = agentsInFilteredSetForTable[agentName];
          agentData.totalCalls++;
          if (call.positiveFlags && call.positiveFlags.length > 0) agentData.positiveCalls++;
          agentData.positiveScore += (call.positiveScore || 0);
          agentData.totalDuration += parseDuration(call.meta["Contact duration"] || "0");
      });

      const sortedAgents = Object.values(agentsInFilteredSetForTable)
        .map(agent => {
          const positiveRatio = agent.totalCalls > 0 ? 
            (agent.positiveCalls / agent.totalCalls) : 0;
          const avgScore = agent.totalCalls > 0 ? 
            (agent.positiveScore / agent.totalCalls) : 0;
          const avgDuration = agent.totalCalls > 0 ?
            (agent.totalDuration / agent.totalCalls) :0;
            
          return {
            ...agent,
            positiveRatio,
            avgScore,
            avgDuration
          };
        })
        .sort((a, b) => b.avgScore - a.avgScore)
        .slice(0, 5); // Top 5 by positive score
      
      // Clear table
      tableBody.innerHTML = '';
      
      // No data case
      if (sortedAgents.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" class="no-data-message">No data available</td>';
        tableBody.appendChild(row);
        return;
      }
      
      // Add rows
      sortedAgents.forEach(agent => {
        const row = document.createElement('tr');
        
        row.innerHTML = `
          <td>${agent.name}</td>
          <td>${agent.totalCalls}</td>
          <td>${(agent.positiveRatio * 100).toFixed(1)}%</td>
          <td>${agent.avgScore.toFixed(2)}</td>
          <td>${agent.avgDuration.toFixed(1)} min</td>
        `;
        
        tableBody.appendChild(row);
      });
    }
    
    // New function for Positive Indicators chart in the "Positive" tab
    function renderPositiveIndicatorsChartActual() {
      console.log("[Debug] renderPositiveIndicatorsChartActual called with filtered data");
      const localPositiveFlags = {};
      dashboardData.filteredCalls.forEach(call => {
          if (call.positiveFlags) {
              call.positiveFlags.forEach(flag => {
                  localPositiveFlags[flag] = (localPositiveFlags[flag] || 0) + 1;
              });
          }
      });
      console.log("[Debug] localPositiveFlags (from filtered):", JSON.parse(JSON.stringify(localPositiveFlags)));

      const canvasElement = document.getElementById('positiveIndicatorsChartActual');
      if (!canvasElement) {
        console.warn("Positive Indicators chart canvas not found");
        return;
      }
      const ctx = canvasElement.getContext('2d');
      
      const topPositiveFlags = Object.entries(localPositiveFlags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10); // Display top 10 positive flags for clarity
      
      const labels = topPositiveFlags.map(f => f[0]);
      const data = topPositiveFlags.map(f => f[1]);

      // Destroy existing chart if it exists
      if (positiveIndicatorsChartActual) {
        positiveIndicatorsChartActual.destroy();
      }
      
      // Create new chart
      positiveIndicatorsChartActual = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Positive Indicator Occurrences',
            data: data,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#ccc',
                stepSize: Math.max(1, Math.ceil(Math.max(...data) / 10))
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            },
            title: {
                display: true,
                text: 'Top Positive Indicators',
                color: '#ccc',
                font: {
                    size: 16
                }
            }
          }
        }
      });
    }
    
    // New function for the positive calls list in the "Positive" tab
    function updatePositiveCallsListActual() {
        console.log("[Debug] updatePositiveCallsListActual called with filtered data");
        const positiveCallsSource = dashboardData.filteredCalls.filter(call => call.positiveScore > 0);
        console.log("[Debug] Calls with positiveScore > 0 (from filtered):", JSON.parse(JSON.stringify(positiveCallsSource)));

        const container = document.getElementById('positiveCallsListActual');
        if (!container) {
            console.warn('Container for actual positive calls list not found.');
            return;
        }

        // Clear container
        container.innerHTML = '';

        // No data case
        if (positiveCallsSource.length === 0) {
            const message = document.createElement('div');
            message.className = 'no-data-message';
            message.textContent = 'No positive calls available';
            container.appendChild(message);
            return;
        }

        // Add positive calls
        positiveCallsSource.forEach(call => {
            const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
            const date = call.meta["Initiation timestamp"] || "Unknown date";
            const duration = call.meta["Contact duration"] || "Unknown";

            const callElement = document.createElement('div');
            callElement.style.margin = '0 0 15px 0';
            callElement.style.padding = '10px';
            callElement.style.background = 'rgba(76, 175, 80, 0.05)';
            callElement.style.borderLeft = '3px solid #4caf50';

            callElement.innerHTML = `
              <div><strong>${agent}</strong> - ${new Date(date).toLocaleString()} - Duration: ${duration}</div>
              <div>Positive Score: <span class="positive-color">${call.positiveScore}</span></div>
              <div>
                ${call.positiveFlags.map(flag =>
                `<span style="display: inline-block; margin: 3px; padding: 2px 6px; background: rgba(76, 175, 80, 0.1); border-radius: 3px; color: #4caf50;">${flag}</span>`
            ).join('')}
              </div>
              ${call.summary ? `<div style="margin-top: 5px; font-style: italic; color: #aaa;">${call.summary}</div>` : ''}
            `;

            container.appendChild(callElement);
        });
    }

    // Helper to get selected agents from the dropdown
    function getSelectedAgentsFromFilter() {
        if (!agentFilterElement) return ['all']; // Should not happen if element is present
        return [...agentFilterElement.selectedOptions].map(option => option.value);
    }

    // Callback for when agent filter changes
    function handleAgentFilterChange(selectedAgents) {
        console.log("Agent filter changed, selected:", selectedAgents);
        localStorage.setItem('selectedAgents', JSON.stringify(selectedAgents));
        
        refreshDashboard();
    }
  </script>
</body>
</html>
