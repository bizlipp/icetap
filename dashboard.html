<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inspiro Analytics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="js/agentFilterManager.js"></script>
  <script src="js/repeatAnalysis.js"></script>
  <script src="js/themeMap.js"></script>
  <script src="js/reportComposer.js"></script>
  <script src="js/reportUI.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    .corporate-header {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      padding: 15px;
      background: #1e1e1e;
      border-radius: 5px;
    }
    .dashboard-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .dashboard-card {
      background: #222;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .card-header {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .accent-color {
      color: #a43ec9;
    }
    .positive-color {
      color: #4caf50;
    }
    .negative-color {
      color: #ff4d4d;
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .stat-card {
      background: #2a2a2a;
      border-radius: 5px;
      padding: 15px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .stat-label {
      font-size: 14px;
      color: #aaa;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    th {
      background-color: #2a2a2a;
      color: #ccc;
    }
    .data-controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #222;
      border-radius: 5px;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    button {
      padding: 8px 15px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .primary-button {
      background: #a43ec9;
      border-color: #a43ec9;
    }
    button:hover {
      background: #444 !important;
    }
    .primary-button:hover {
      background: #b44dd9 !important;
      border-color: #b44dd9;
    }
    .no-data-message {
      text-align: center;
      padding: 30px;
      color: #888;
      font-style: italic;
    }

    /* Tab System Styles */
    .tab-navigation {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #333; /* Separator for tabs */
    }

    .tab-button {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #222; /* Darker, inactive tab */
      color: #aaa;
      border: none;
      border-bottom: 3px solid transparent; /* For active indicator */
      margin-right: 5px;
      transition: background-color 0.3s, color 0.3s, border-bottom 0.3s;
      font-size: 16px;
      border-top-left-radius: 5px; /* Rounded corners for tabs */
      border-top-right-radius: 5px;
    }

    .tab-button:hover {
      background-color: #333 !important; /* Consistent hover with other buttons */
      color: #fff !important;
    }

    .tab-button.active {
      background-color: #1a1a1a !important; /* Match body background for seamless look */
      color: #a43ec9 !important; /* Accent color for active tab text */
      border-bottom: 3px solid #a43ec9; /* Accent color indicator */
      font-weight: bold;
    }

    .tab-content {
      display: none;
      padding-top: 20px; /* Space between tab nav and content */
      animation: fadeIn 0.5s; /* Simple fade-in animation */
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* End Tab System Styles */

    /* Styles for Agent Performance Snapshots tags */
    .snapshot-tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.8em;
      margin-right: 4px;
      margin-bottom: 4px; /* if they wrap */
    }
    .snapshot-tag-flag {
      background-color: rgba(255, 77, 77, 0.1); /* Light red */
      color: #ff4d4d; /* Red */
      border: 1px solid rgba(255, 77, 77, 0.3);
    }
    .snapshot-tag-positive {
      background-color: rgba(76, 175, 80, 0.1); /* Light green */
      color: #4caf50; /* Green */
      border: 1px solid rgba(76, 175, 80, 0.3);
    }
    /* End Styles for Agent Performance Snapshots tags */
  </style>
</head>
<body>
  <div class="corporate-header">
    <h1 style="font-family: Arial, sans-serif;">
      <span style="color: #000; font-size: 42px; font-weight: 900;">inspi</span><span style="color: #a43ec9; font-size: 42px; font-weight: 900;">r</span><span style="color: #000; font-size: 42px; font-weight: 900;">o</span> <span style="font-size: 28px; font-weight: bold;">Analytics Dashboard</span>
    </h1>
    <p>Comprehensive analytics of call transcripts for enhanced customer service performance.</p>
  </div>

  <div class="data-controls">
    <button id="loadDataButton" class="primary-button">Load Data from Parser</button>
    <button id="refreshButton">Refresh Dashboard</button>
    <div id="dataStatus">No data loaded</div>
    <div style="margin-left: auto;">
        <label for="agentFilter" style="margin-right: 5px; font-size: 14px;">Filter Agents:</label>
        <select id="agentFilter" multiple style="min-width: 200px; padding: 5px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;"></select>
    </div>
  </div>

  <div class="tab-navigation">
    <button class="tab-button active" data-tab="overviewTab">üìä Overview</button>
    <button class="tab-button" data-tab="distributionTab">üìà Distribution Analysis</button>
    <button class="tab-button" data-tab="insightsTab">üë• Agent & Caller Insights</button>
    <button class="tab-button" data-tab="positiveTab">üåü Positive Performance</button>
    <button class="tab-button" data-tab="repeatCallersTab">üîÅ Repeat Callers</button>
    <button class="tab-button" data-tab="coachingTab">üß† Coaching & Follow-up</button>
    <button class="tab-button" data-tab="reportsTab">üìã Reports & Export</button>
  </div>

  <div id="overviewTab" class="tab-content active">
    <div class="dashboard-container">
      <!-- Summary Statistics -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Call Statistics Summary</span>
        </div>
        <div class="stat-grid">
          <div class="stat-card">
            <div class="stat-label">Total Calls</div>
            <div class="stat-value" id="totalCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Flagged Calls</div>
            <div class="stat-value negative-color" id="flaggedCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Positive Calls</div>
            <div class="stat-value positive-color" id="positiveCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Avg. Call Duration</div>
            <div class="stat-value" id="avgDuration">0 min</div>
          </div>
        </div>
      </div>

      <!-- Agent Performance -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üë• Agent Performance</span>
        </div>
        <div class="chart-container">
          <canvas id="agentPerformanceChart"></canvas>
        </div>
      </div>

      <!-- Flag Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üö© Flag Distribution</span>
        </div>
        <div class="chart-container">
          <canvas id="flagDistributionChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div id="distributionTab" class="tab-content">
    <div class="dashboard-container">
      <!-- Positive Indicators (Moving to Positive Tab later, placeholder for structure) -->
      <!-- This card will be moved. Keeping structure for now. -->
      <div class="dashboard-card" style="display:none;" id="positiveIndicatorsCardPlaceholder">
        <div class="card-header">
          <span>üåü Positive Indicators (Placeholder)</span>
        </div>
        <div class="chart-container">
          <canvas id="positiveIndicatorsChart"></canvas>
        </div>
      </div>

      <!-- Time Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>‚è∞ Call Time Distribution</span>
        </div>
        <div class="chart-container">
          <canvas id="timeDistributionChart"></canvas>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
          <canvas id="dayDistributionChart"></canvas>
        </div>
      </div>
      
      <!-- Channel & Queue Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üì± Channel & Queue Distribution</span>
        </div>
        <div style="display: flex; gap: 20px;">
          <div style="flex: 1;">
            <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Channels</h3>
            <div class="chart-container" style="height: 200px;">
              <canvas id="channelDistributionChart"></canvas>
            </div>
          </div>
          <div style="flex: 1;">
            <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Queues</h3>
            <div class="chart-container" style="height: 200px;">
              <canvas id="queueDistributionChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="dashboard-container">
      <!-- Categories Analysis -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Categories Analysis</span>
        </div>
        <div class="chart-container">
          <canvas id="categoriesChart"></canvas>
        </div>
        <div id="categoryDetails" style="margin-top: 15px; padding: 10px;">
          <div class="no-data-message">No categories data available</div>
        </div>
      </div>
    </div>
  </div>

  <div id="insightsTab" class="tab-content">
    <div class="dashboard-container">
      <!-- Repeat Callers Analysis - This will be moved -->
      <div class="dashboard-card" id="repeatCallersCardOriginalLocation" style="display:none;"> 
        <div class="card-header">
          <span>üîÅ Repeat Callers Analysis (Original Location - Hidden)</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Customer Phone</th>
              <th>Call Count</th>
              <th>Span (Days)</th>
              <th>First Call Date</th>
              <th>Latest Call Date</th>
              <th>Top Themes</th>
              <th>Agent Trail</th>
              <th>Pattern Tag</th>
            </tr>
          </thead>
          <tbody id="repeatCallersBodyOriginalLocation">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- Common Topics -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üîç Common Topics</span>
        </div>
        <div id="commonTopics" style="padding: 10px; display: flex; flex-wrap: wrap; gap: 8px;">
          <div class="no-data-message">No data available</div>
        </div>
      </div>

      <!-- New: Flag & Positive Indicator Trends -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Flag & Positive Indicator Snapshot</span>
        </div>
        <div style="display: flex; gap: 20px; margin-bottom:20px;">
          <div style="flex: 1;">
            <h4 style="font-size: 16px; color: #aaa; margin-bottom: 10px; text-align: center;">Top 5 Flags</h4>
            <div class="chart-container" style="height: 250px;">
              <canvas id="topFlagsChartInsights"></canvas>
            </div>
          </div>
          <div style="flex: 1;">
            <h4 style="font-size: 16px; color: #aaa; margin-bottom: 10px; text-align: center;">Top 5 Positive Indicators</h4>
            <div class="chart-container" style="height: 250px;">
              <canvas id="topPositiveIndicatorsChartInsights"></canvas>
            </div>
          </div>
        </div>
        <!-- Line Chart for Trends -->
        <div>
             <h4 style="font-size: 16px; color: #aaa; margin-bottom: 10px; text-align: center;">Daily Flag & Positive Indicator Trends</h4>
            <div class="chart-container" style="height: 300px;">
                <canvas id="flagPositiveTrendsChart"></canvas>
            </div>
        </div>
      </div>
      <!-- End New: Flag & Positive Indicator Trends -->

    </div>
    
    <div class="dashboard-container">
      <!-- Top Agents Table - This will be moved -->
      <div class="dashboard-card" id="topAgentsCardOriginalLocation" style="display:none;">
        <div class="card-header">
          <span>üèÜ Top Performing Agents (Original Location - Hidden)</span>
        </div>
        <table id="topAgentsTableOriginalLocation">
          <thead>
            <tr>
              <th>Agent</th>
              <th>Total Calls</th>
              <th>Positive Ratio</th>
              <th>Avg Score</th>
              <th>Avg Duration</th>
            </tr>
          </thead>
          <tbody id="topAgentsBodyOriginalLocation">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- Recent Positive Calls (Moving to Positive Tab later, placeholder for structure)-->
      <div class="dashboard-card" style="display:none;" id="recentPositiveCallsPlaceholder">
        <div class="card-header">
          <span>‚úÖ Recent Positive Calls (Placeholder)</span>
        </div>
        <div id="positiveCallsList">
          <div class="no-data-message">No data available</div>
        </div>
      </div>
    </div>
  </div>

  <div id="positiveTab" class="tab-content">
    <div class="dashboard-container">
        <!-- Positive Indicators -->
        <div class="dashboard-card" id="positiveIndicatorsCardActual">
            <div class="card-header">
                <span>üåü Positive Indicators</span>
            </div>
            <div class="chart-container">
                <canvas id="positiveIndicatorsChartActual"></canvas> 
            </div>
        </div>
        <!-- Recent Positive Calls -->
        <div class="dashboard-card" id="recentPositiveCallsActual">
            <div class="card-header">
                <span>‚úÖ Recent Positive Calls</span>
            </div>
            <div id="positiveCallsListActual" style="max-height: 400px; overflow-y: auto;"> 
                <div class="no-data-message">No data available</div>
            </div>
        </div>
        <!-- Top Performing Agents - Moved Here -->
        <div class="dashboard-card" id="topAgentsCardMoved">
          <div class="card-header">
            <span>üèÜ Top Performing Agents</span>
          </div>
          <table id="topAgentsTable">
            <thead>
              <tr>
                <th>Agent</th>
                <th>Total Calls</th>
                <th>Positive Ratio</th>
                <th>Avg Score</th>
                <th>Avg Duration</th>
              </tr>
            </thead>
            <tbody id="topAgentsBody">
              <tr>
                <td colspan="5" class="no-data-message">No data available</td>
              </tr>
            </tbody>
          </table>
        </div>
    </div>
  </div> <!-- End of positiveTab -->

  <!-- New Tab: Repeat Caller Analytics -->
  <div id="repeatCallersTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üîÅ Repeat Callers Analysis</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Customer Phone</th>
              <th>Call Count</th>
              <th>Span (Days)</th>
              <th>First Call Date</th>
              <th>Latest Call Date</th>
              <th>Top Themes</th>
              <th>Agent Trail</th>
              <th>Pattern Tag</th>
            </tr>
          </thead>
          <tbody id="repeatCallersBody">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <!-- Root Cause Reporting Block -->
    <div class="dashboard-card" style="margin-top: 20px;">
        <div class="card-header">
            <span>üîç Root Cause Analysis & Coaching Summary</span>
            <button id="copyCoachingSummaryButton" style="margin-left: auto;">Copy Summary</button>
        </div>
        <div id="repeatSummaryBlock" style="padding: 15px; min-height: 100px; background: #2a2a2a; border-radius: 0 0 5px 5px;">
            <div class="no-data-message">Coaching summary will appear here.</div>
        </div>
    </div>
    <!-- Placeholders for future content -->
    <div class="dashboard-container" style="margin-top: 20px;">
        <div class="dashboard-card">
            <div class="card-header">
                <span>üìä Callback Timing Charts</span>
            </div>
            <div id="repeatCallersTimingCharts" style="display: flex; flex-wrap: wrap; gap: 15px;">
                <!-- Content will be rendered by js/repeatAnalysis.js -->
                <!-- This div will now contain volumeChartDiv and pieChartDiv -->
            </div>
        </div>
        <div class="dashboard-card">
            <div class="card-header">
                <span>üß† Agent-Specific Insights (Repeat Callers)</span>
            </div>
            <div id="repeatCallersAgentInsights">
                <!-- Content will be rendered by js/repeatAnalysis.js -->
            </div>
        </div>
    </div>
  </div> <!-- End of repeatCallersTab -->

  <!-- New Tab: Coaching & Follow-up -->
  <div id="coachingTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üß† Coaching & Follow-up</span>
        </div>
        <div style="padding: 20px;">
          <p>Coaching plans, follow-up actions, and agent development tools will be available here in a future update.</p>
          <p><em>Stay tuned!</em></p>
        </div>
      </div>
    </div>
  </div> <!-- End of coachingTab -->

  <!-- New Tab: Reports & Export -->
  <div id="reportsTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìã Reports & Export</span>
        </div>
        <div style="padding: 20px;">
          <p>Advanced report generation, data export configurations, and distribution options will be available here.</p>
          <p><em>Coming soon!</em></p>
        </div>
      </div>
    </div>
  </div> <!-- End of reportsTab -->

  <script>
    // Dashboard state
    window.dashboardData = {
      calls: [],
      filteredCalls: [],
      agents: {},
      agentColors: {},
      flags: {},
      positiveFlags: {},
      hourDistribution: new Array(24).fill(0),
      dayDistribution: new Array(7).fill(0),
      channelDistribution: {},
      queueDistribution: {},
      wordFrequency: {},
      topicFrequency: {},
      repeatCallers: {},
      categories: {},
      dailyFlagCounts: {}, // New for trend chart
      dailyPositiveCounts: {}, // New for trend chart
      loaded: false
    };
    
    window.themeMap = {
      // Billing & Payments
      "bill": "Billing", "billing": "Billing", "charge": "Billing", "charged": "Billing", "payment": "Billing", "invoice": "Billing", "refund": "Billing", "overcharge": "Billing", "statement": "Billing",
      // Cancellations & Disconnections
      "cancel": "Cancellation", "cancellation": "Cancellation", "disconnect": "Cancellation", "terminate": "Cancellation", "termination": "Cancellation", "close account": "Cancellation",
      // Technical Issues & Support
      "issue": "Technical Issue", "problem": "Technical Issue", "error": "Technical Issue", "broken": "Technical Issue", "fix": "Technical Issue", "support": "Technical Issue", "password": "Login/Access", "login": "Login/Access", "username": "Login/Access", "account access": "Login/Access",
      // Product & Service Info
      "service": "Service Inquiry", "product": "Product Inquiry", "feature": "Feature Inquiry", "plan": "Plan Inquiry", "upgrade": "Service Change", "downgrade": "Service Change", "change plan": "Service Change",
      // Agent & Interaction Quality
      "agent": "Agent Interaction", "representative": "Agent Interaction", "helpful": "Positive Feedback", "great service": "Positive Feedback", "thank you": "Positive Feedback", "appreciate": "Positive Feedback", "complaint": "Negative Feedback", "unhelpful": "Negative Feedback", "frustrated": "Negative Feedback", "angry": "Negative Feedback",
      // Common Actions/Requests
      "update": "Update Information", "address": "Update Information", "email": "Update Information", "phone number": "Update Information",
      // Time & Urgency
      "urgent": "Urgent Matter", "asap": "Urgent Matter", "immediately": "Urgent Matter",
      // Follow-up & History
      "follow up": "Follow-up", "called before": "Previous Call", "last call": "Previous Call", "still waiting": "Ongoing Issue"
    };

    window.softSkillKeywordMap = {
      "Empathy": ["understand", "understood", "appreciate", "listen", "listened", "patient", "patience", "care", "caring", "sympathy", "empathetic"],
      "Communication": ["clear", "clearly", "explain", "explained", "concise", "articulate", "communication", "helpful", "information"],
      "Problem Solving": ["resolve", "resolved", "solution", "problem solved", "fix", "fixed", "issue resolved", "effective"],
      "Professionalism": ["professional", "courteous", "polite", "respectful", "manner"],
      "Efficiency": ["quick", "quickly", "efficient", "fast", "prompt"]
      // Add more skills and keywords as needed
    };

    // Expanded Stop Words List
    const STOP_WORDS = [
        "a", "about", "above", "after", "again", "against", "all", "am", "an", "and", "any", "are", "aren't", "as", "at",
        "be", "because", "been", "before", "being", "below", "between", "both", "but", "by",
        "can", "cannot", "can't", "could", "couldn't",
        "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down", "during",
        "each",
        "few", "for", "from", "further",
        "had", "hadn't", "has", "hasn't", "have", "haven't", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers", "herself", "him", "himself", "his", "how", "how's",
        "i", "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "isn't", "it", "it's", "its", "itself",
        "just", "know",
        "let's", "like",
        "me", "more", "most", "mustn't", "my", "myself",
        "no", "nor", "not", "now",
        "of", "off", "on", "once", "only", "or", "other", "ought", "our", "ours", "ourselves", "out", "over", "own",
        "please",
        "same", "shan't", "she", "she'd", "she'll", "she's", "should", "shouldn't", "so", "some", "such",
        "than", "that", "that's", "the", "their", "theirs", "them", "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll", "they're", "they've", "this", "those", "through", "to", "too",
        "under", "until", "up",
        "very",
        "was", "wasn't", "we", "we'd", "we'll", "we're", "we've", "were", "weren't", "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's", "whom", "why", "why's", "with", "won't", "would", "wouldn't",
        "yeah", "yes", "yet", "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself", "yourselves",
        // Common conversational fillers & short words
        "okay", "ok", "oh", "ah", "uh", "um", "hmm", "huh", "got", "hi", "hey", "hello", "bye", "goodbye", "thanks", "thankyou",
        "able", "actually", "also", "always", "another", "anything", "around", "away", "back", "become", "call", "calling", "came", "come", "coming",
        "day", "days", "done", "else", "even", "every", "everyone", "everything", "feel", "find", "first", "five", "four", "get", "getting", "give", "giving", "go", "going", "gonna", "gotta", "guys",
        "hello", "help", "here", "hi", "hour", "hours", "information", "isnt", "item", "items", "kinda", "knew", "last", "left", "let", "little", "long", "look", "looking", "lot",
        "made", "make", "making", "man", "many", "maybe", "mean", "means", "might", "minute", "minutes", "moment", "month", "months", "morning", "mr", "mrs", "ms", "much", "name", "need", "never", "new", "next", "nice", "night", "nope",
        "number", "numbers", "one", "ones", "opportunity", "options", "order", "orders", "other", "others", "our", "ours", "out", "over", "own",
        "part", "parts", "past", "people", "percent", "perhaps", "person", "phone", "place", "play", "point", "possible", "pretty", "probably", "put",
        "question", "questions", "quite",
        "rather", "real", "really", "reason", "regards", "remember", "remove", "regard", "regarding", "response", "right", "room",
        "said", "saw", "say", "saying", "second", "see", "seeing", "seem", "seemed", "seems", "send", "sent", "serious", "several", "shall", "show", "showed", "shows", "side", "since", "sir", "situation", "small", "somebody", "someone", "something", "sometime", "sometimes", "somewhere", "soon", "sorry", "sort", "speak", "start", "started", "state", "still", "stuff", "sure", "system",
        "talk", "talking", "tell", "thing", "things", "think", "thinking", "though", "three", "time", "times", "today", "told", "tomorrow", "tonight", "took", "totally", "try", "trying", "two",
        "understand", "use", "used", "using",
        "version",
        "wait", "waiting", "want", "wanna", "way", "week", "weeks", "welcome", "well", "went", "whatever", "whole", "whose", "will", "wish", "within", "without", "word", "words", "work", "working", "world", "write",
        "yesterday", "yet",
        // Words that might be too generic depending on context, but good to filter for general topics
        "account", "action", "address", "advice", "afternoon", "age", "agent", "alert", "amount", "application", "area", "ask", "asked", "asking", "assistance", "available",
        "balance", "based", "basis", "begin", "believe", "best", "better", "big", "bit", "book", "brand", "business", "buy",
        "card", "care", "case", "cases", "cause", "center", "certain", "certainly", "chance", "change", "changes", "character", "check", "checking", "choice", "choose", "clear", "clearly", "client", "close", "company", "complete", "completely", "concern", "condition", "conference", "confirm", "confirmation", "connect", "consider", "contact", "continue", "contract", "control", "conversation", "copy", "correct", "cost", "country", "couple", "course", "create", "credit", "current", "currently", "customer",
        "data", "date", "deal", "dear", "decide", "decision", "define", "definitely", "degree", "department", "depend", "describe", "description", "detail", "details", "develop", "different", "difficult", "direct", "discuss", "document", "double", "doubt", "drive", "due", "duty",
        "earlier", "early", "easily", "easy", "effect", "either", "end", "ensure", "enter", "entire", "especially", "etc", "exact", "exactly", "example", "except", "expect", "experience", "explain", "express", "extra",
        "face", "fact", "factor", "fail", "fall", "family", "far", "fast", "father", "fear", "feedback", "field", "figure", "file", "fill", "final", "finally", "financial", "fine", "finish", "firm", "follow", "following", "foot", "force", "form", "former", "forward", "free", "friend", "front", "full", "function", "fund", "future",
        "game", "general", "generally", "given", "glad", "goal", "god", "good", "government", "great", "ground", "group", "grow", "guess", "guy",
        "half", "hand", "handle", "happen", "happened", "hard", "head", "hear", "heard", "heart", "hello", "hence", "hers", "high", "history", "hit", "hold", "home", "hope", "house", "however", "human", "hundred",
        "idea", "identify", "image", "important", "impossible", "improve", "include", "including", "increase", "indeed", "indicate", "individual", "industry", "influence", "inside", "instance", "instead", "interest", "international", "interview", "introduce", "investigation", "involve", "involved", "itself",
        "job", "join", "keep", "key", "kind", "knowledge",
        "language", "large", "later", "latest", "latter", "law", "lay", "lead", "learn", "least", "leave", "legal", "less", "letter", "level", "life", "light", "line", "list", "listen", "live", "local", "lose", "love", "low",
        "main", "major", "manage", "management", "manner", "mark", "market", "match", "material", "matter", "may", "measure", "media", "meet", "meeting", "member", "mention", "message", "method", "middle", "million", "mind", "miss", "model", "money", "month", "mother", "move", "movement",
        "nature", "near", "nearly", "necessary", "neither", "network", "news", "normal", "note", "nothing", "notice",
        "object", "observe", "obtain", "obvious", "occur", "offer", "office", "often", "old", "open", "operate", "operation", "opinion", "option", "organisation", "original", "otherwise", "outside",
        "page", "paper", "parent", "particular", "particularly", "party", "pass", "pattern", "pay", "per", "perform", "performance", "period", "personal", "picture", "piece", "plan", "play", "plus", "pm", "policy", "political", "pool", "poor", "popular", "position", "positive", "power", "practice", "prefer", "prepare", "present", "president", "press", "pressure", "previous", "price", "primary", "principle", "print", "prior", "private", "process", "produce", "product", "production", "profile", "program", "progress", "project", "promise", "proper", "property", "propose", "protect", "provide", "public", "pull", "purpose", "push", "put",
        "quality", "quarter", "question", "quick", "quickly",
        "race", "radio", "raise", "range", "rate", "reach", "read", "ready", "realize", "receive", "recent", "recently", "recognize", "record", "red", "reduce", "refer", "reference", "reflect", "regard", "region", "relate", "related", "relation", "relationship", "release", "remain", "remember", "report", "represent", "require", "research", "resource", "respect", "respond", "result", "return", "reveal", "review", "road", "role", "roll", "room", "rule", "run",
        "safe", "sale", "save", "scale", "scene", "school", "science", "score", "search", "season", "seat", "section", "secure", "security", "select", "sell", "sense", "separate", "series", "serve", "service", "session", "set", "settle", "seven", "share", "short", "shot", "simple", "simply", "single", "sit", "site", "size", "skill", "social", "society", "solution", "somehow", "son", "song", "sort", "sound", "source", "south", "space", "speak", "special", "specific", "specifically", "speech", "speed", "spend", "sport", "spring", "staff", "stage", "stand", "standard", "star", "start", "statement", "station", "status", "stay", "step", "stock", "stop", "store", "story", "strategy", "street", "strong", "structure", "student", "study", "style", "subject", "succeed", "success", "successful", "suddenly", "suffer", "suggest", "suit", "summer", "sun", "supply", "support", "suppose", "surface", "survey",
        "table", "take", "tax", "teach", "team", "technology", "telephone", "television", "term", "terms", "test", "thank", "therefore", "thing", "third", "thought", "thousand", "threat", "throughout", "throw", "thus", "ticket", "title", "together", "tomorrow", "top", "total", "touch", "toward", "town", "track", "trade", "traditional", "train", "training", "transfer", "transport", "travel", "treat", "treatment", "tree", "trial", "trip", "trouble", "true", "trust", "turn", "tv", "twelve", "twenty", "type",
        "unable", "unit", "united", "university", "upon", "usually",
        "value", "various", "view", "visit", "voice", "volume",
        "walk", "wall", "war", "watch", "water", "wear", "weather", "website", "week", "weight", "west", "white", "whole", "wide", "wife", "win", "wind", "window", "wine", "winter", "woman", "women", "wonder", "word", "worker", "world", "worry", "worth", "writer", "writing", "wrong",
        "year", "yesterday", "young",
        "zone",
        // Words from the original exclusion list (some might be redundant now)
        "cxo-supcall-de-escalate", "credit_debit_number", "choosing",
        "cxo-wireless-call-issues"
    ];
    
    // DOM elements
    const loadDataButton = document.getElementById('loadDataButton');
    const refreshButton = document.getElementById('refreshButton');
    const dataStatus = document.getElementById('dataStatus');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    const agentFilterElement = document.getElementById('agentFilter');
    
    // Chart objects
    let agentPerformanceChart = null;
    let flagDistributionChart = null;
    let positiveIndicatorsChartActual = null;
    let timeDistributionChart = null;
    let dayDistributionChart = null;
    let channelDistributionChart = null;
    let queueDistributionChart = null;
    let categoriesChart = null;
    let callbackVolumeChart = null;
    let agentRepeatCountsChart = null;
    let repeatThemesPieChart = null;
    let topFlagsChartInsights = null; // New chart
    let topPositiveIndicatorsChartInsights = null; // New chart
    let flagPositiveTrendsChart = null; // New chart for trends
    
    // Constants
    const DAY_NAMES = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    window.COLOR_POOL = [
        'rgba(164, 62, 201, 0.8)', 'rgba(76, 175, 80, 0.8)', 'rgba(255, 77, 77, 0.8)', 
        'rgba(33, 150, 243, 0.8)', 'rgba(255, 152, 0, 0.8)', 'rgba(0, 150, 136, 0.8)',
        'rgba(233, 30, 99, 0.8)', 'rgba(139, 195, 74, 0.8)', 'rgba(255, 235, 59, 0.8)',
        'rgba(121, 85, 72, 0.8)', 'rgba(158, 158, 158, 0.8)', 'rgba(96, 125, 139, 0.8)'
    ];
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      loadDataButton.addEventListener('click', loadDataFromParser);
      refreshButton.addEventListener('click', refreshDashboard);

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          button.classList.add('active');
          const activeTabId = button.dataset.tab;
          document.getElementById(activeTabId).classList.add('active');
          
          if (window.dashboardData.loaded) {
            renderActiveTabContent(activeTabId);
            if (activeTabId === 'repeatCallersTab') {
                if (document.getElementById('repeatSummaryBlock') && document.getElementById('copyCoachingSummaryButton')) {
                    initializeReportUI('repeatSummaryBlock', 'copyCoachingSummaryButton');
                }
            }
          }
        });
      });

      loadDataFromParser().then(() => {
        if (window.dashboardData.loaded) {
          const uniqueAgentNames = Object.keys(window.dashboardData.agents).sort();
          initializeAgentFilterDropdown(uniqueAgentNames, handleAgentFilterChange);
          handleAgentFilterChange(getSelectedAgentsFromFilter());
        }
        if (tabButtons.length > 0 && !document.querySelector('.tab-button.active')) {
            tabButtons[0].click();
        }
      }); 
    });
    
    function renderActiveTabContent(activeTabId) {
        if (!window.dashboardData.loaded || !window.dashboardData.filteredCalls || window.dashboardData.filteredCalls.length === 0) {
            console.log("No filtered data to render for tab:", activeTabId);
            if (activeTabId === 'overviewTab') {
                if (agentPerformanceChart) agentPerformanceChart.destroy();
                if (flagDistributionChart) flagDistributionChart.destroy();
                agentPerformanceChart = null;
                flagDistributionChart = null;
            } else if (activeTabId === 'distributionTab') {
                if (timeDistributionChart) timeDistributionChart.destroy();
                if (dayDistributionChart) dayDistributionChart.destroy();
                if (channelDistributionChart) channelDistributionChart.destroy();
                if (queueDistributionChart) queueDistributionChart.destroy();
                if (categoriesChart) categoriesChart.destroy();
                timeDistributionChart = null;
                dayDistributionChart = null;
                channelDistributionChart = null;
                queueDistributionChart = null;
                categoriesChart = null;
                if (callbackVolumeChart) callbackVolumeChart.destroy();
                callbackVolumeChart = null;
                if (agentRepeatCountsChart) agentRepeatCountsChart.destroy();
                agentRepeatCountsChart = null;
                if (repeatThemesPieChart) repeatThemesPieChart.destroy();
                repeatThemesPieChart = null;
                if (flagPositiveTrendsChart) flagPositiveTrendsChart.destroy(); // Destroy new chart
                flagPositiveTrendsChart = null;
            } else if (activeTabId === 'positiveTab') {
                if (positiveIndicatorsChartActual) positiveIndicatorsChartActual.destroy();
                positiveIndicatorsChartActual = null;
                document.getElementById('positiveCallsListActual').innerHTML = '<div class="no-data-message">No positive performance data for current filter</div>';
                document.getElementById('topAgentsBody').innerHTML = '<tr><td colspan="5" class="no-data-message">No agent data for current filter</td></tr>';
            } else if (activeTabId === 'repeatCallersTab') {
                updateRepeatCallersTabContent(window.dashboardData.filteredCalls);
            } else if (activeTabId === 'insightsTab') {
                document.getElementById('commonTopics').innerHTML = '<div class="no-data-message">No common topics for current filter</div>';
                document.getElementById('agentSnapshotsContainer').innerHTML = '<div class="no-data-message">Select agents to see their performance snapshots.</div>';
                if (topFlagsChartInsights) topFlagsChartInsights.destroy();
                topFlagsChartInsights = null;
                if (topPositiveIndicatorsChartInsights) topPositiveIndicatorsChartInsights.destroy();
                topPositiveIndicatorsChartInsights = null;
                if (flagPositiveTrendsChart) flagPositiveTrendsChart.destroy(); // Destroy new chart
                flagPositiveTrendsChart = null;
            }
            return;
        }

        if (activeTabId === 'overviewTab') {
            renderAgentPerformanceChart();
            renderFlagDistributionChart();
        } else if (activeTabId === 'distributionTab') {
            renderTimeDistributionCharts();
            renderChannelAndQueueCharts();
            renderCategoriesChart();
        } else if (activeTabId === 'insightsTab') {
            updateCommonTopics();
            updateAgentPerformanceSnapshots();
            renderTopFlagsChartInsights(); // New function call
            renderTopPositiveIndicatorsChartInsights(); // New function call
            renderFlagPositiveTrendsChart(); // New function call
        } else if (activeTabId === 'positiveTab') {
            renderPositiveIndicatorsChartActual(); 
            updatePositiveCallsListActual(); 
            updateTopAgentsTable();
        } else if (activeTabId === 'repeatCallersTab') {
            updateRepeatCallersTabContent(window.dashboardData.filteredCalls);
        } else if (activeTabId === 'coachingTab') {
            // Placeholder: No dynamic content to render yet
        } else if (activeTabId === 'reportsTab') {
            // Placeholder: No dynamic content to render yet
        }
    }
    
    async function loadDataFromParser() {
      dataStatus.textContent = "Attempting to load data...";
      window.dashboardData.loaded = false;
      window.dashboardData.calls = [];
      window.dashboardData.filteredCalls = [];
      try {
        const storedData = localStorage.getItem('inspiroCallData');
        
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            if (Array.isArray(parsedData) && parsedData.length > 0) {
              window.dashboardData.calls = parsedData;
              
              const allAgentNamesInDataset = [...new Set(window.dashboardData.calls.map(call => call.meta["Agent"] || call.meta["Agent name"] || "Unknown"))].sort();
              allAgentNamesInDataset.forEach((name, index) => {
                  if (name !== "Unknown") {
                    window.dashboardData.agentColors[name] = window.COLOR_POOL[index % window.COLOR_POOL.length];
                  }
              });

              processData();
              dataStatus.textContent = `‚úÖ Loaded ${window.dashboardData.calls.length} calls`;
              window.dashboardData.loaded = true;
              
              const uniqueAgentNames = Object.keys(window.dashboardData.agents).sort();
              initializeAgentFilterDropdown(uniqueAgentNames, handleAgentFilterChange);
              handleAgentFilterChange(getSelectedAgentsFromFilter());
              return;
            }
          } catch (parseError) {
            console.error("Error parsing stored data:", parseError);
          }
        }
        
        dataStatus.textContent = "No data found. Please parse calls in the main tool first.";
      } catch (error) {
        dataStatus.textContent = `‚ùå Error: ${error.message}`;
        console.error(error);
      }
    }
    
    function processData() {
      window.dashboardData.agents = {};
      window.dashboardData.flags = {};
      window.dashboardData.positiveFlags = {};
      window.dashboardData.hourDistribution = new Array(24).fill(0);
      window.dashboardData.dayDistribution = new Array(7).fill(0);
      window.dashboardData.channelDistribution = {};
      window.dashboardData.queueDistribution = {};
      window.dashboardData.wordFrequency = {};
      window.dashboardData.topicFrequency = {};
      window.dashboardData.repeatCallers = {};
      window.dashboardData.categories = {};
      window.dashboardData.dailyFlagCounts = {}; // Initialize
      window.dashboardData.dailyPositiveCounts = {}; // Initialize
      
      const selectedAgents = getSelectedAgentsFromFilter();
      const isFiltering = selectedAgents.length > 0 && !selectedAgents.includes('all');

      window.dashboardData.filteredCalls = window.dashboardData.calls.filter(call => {
        if (!isFiltering) return true;
        const agentName = call.meta["Agent name"] || call.meta["Agent"] || "Unknown";
        return selectedAgents.includes(agentName);
      });

      window.dashboardData.filteredCalls.forEach(call => {
        const agentName = call.meta["Agent name"] || call.meta["Agent"] || "Unknown";
        if (!window.dashboardData.agents[agentName]) {
          window.dashboardData.agents[agentName] = {
            name: agentName,
            totalCalls: 0,
            flaggedCalls: 0,
            positiveCalls: 0,
            positiveScore: 0,
            avgDuration: 0,
            totalDuration: 0,
            softSkills: {} // Initialize soft skills for the agent
          };
        }
        
        const agentData = window.dashboardData.agents[agentName];
        agentData.totalCalls++;
        
        if (call.flags && call.flags.length > 0) {
          agentData.flaggedCalls++;
        }
        
        if (call.positiveFlags && call.positiveFlags.length > 0) {
          agentData.positiveCalls++;
        }
        
        agentData.positiveScore += (call.positiveScore || 0);
        
        const durationText = call.meta["Contact duration"] || "0";
        const durationMinutes = parseDuration(durationText);
        agentData.totalDuration += durationMinutes;
        
        if (call.flags) {
          call.flags.forEach(flag => {
            window.dashboardData.flags[flag] = (window.dashboardData.flags[flag] || 0) + 1;
          });
        }
        
        if (call.positiveFlags) {
          call.positiveFlags.forEach(flag => {
            window.dashboardData.positiveFlags[flag] = (window.dashboardData.positiveFlags[flag] || 0) + 1;
          });
        }
        
        try {
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              const hour = date.getHours();
              window.dashboardData.hourDistribution[hour]++;
              const day = date.getDay();
              window.dashboardData.dayDistribution[day]++;

              // Aggregate for daily trends chart
              const dateString = date.toISOString().split('T')[0]; // YYYY-MM-DD
              if (!window.dashboardData.dailyFlagCounts[dateString]) {
                window.dashboardData.dailyFlagCounts[dateString] = 0;
              }
              if (!window.dashboardData.dailyPositiveCounts[dateString]) {
                window.dashboardData.dailyPositiveCounts[dateString] = 0;
              }
              if (call.flags && call.flags.length > 0) {
                window.dashboardData.dailyFlagCounts[dateString]++;
              }
              if (call.positiveFlags && call.positiveFlags.length > 0) {
                window.dashboardData.dailyPositiveCounts[dateString]++;
              }
            }
          }
        } catch (error) {
          console.error("Error processing timestamp:", error);
        }
        
        const channel = call.meta["Channel"] || "Unknown";
        window.dashboardData.channelDistribution[channel] = (window.dashboardData.channelDistribution[channel] || 0) + 1;
        
        const queue = call.meta["Queue"] || "Unknown";
        window.dashboardData.queueDistribution[queue] = (window.dashboardData.queueDistribution[queue] || 0) + 1;
        
        if (call.transcript && call.transcript.length > 0) {
          const callTextForSkills = call.transcript.map(entry => entry.text || '').join(' ').toLowerCase();
          const callPositiveFlags = call.positiveFlags || [];

          Object.keys(window.softSkillKeywordMap).forEach(skill => {
            if (!agentData.softSkills[skill]) {
              agentData.softSkills[skill] = 0;
            }
            window.softSkillKeywordMap[skill].forEach(keyword => {
              // Check in transcript text
              if (callTextForSkills.includes(keyword)) {
                agentData.softSkills[skill]++;
              }
              // Check in positive flags (exact match)
              if (callPositiveFlags.includes(keyword)) {
                agentData.softSkills[skill]++; // Could add more weight or handle differently
              }
            });
          });

          call.transcript.forEach(entry => {
            if (entry.text) {
              const text = entry.text.toLowerCase();
              const words = text.split(/\\s+/).filter(word => {
                const cleanedWord = word.replace(/[^a-z0-9']/gi, ''); // Basic cleaning
                return cleanedWord.length > 2 && !STOP_WORDS.includes(cleanedWord);
              });
              
              words.forEach(word => {
                const cleanedWord = word.replace(/[^a-z0-9']/gi, '');
                let themed = false;
                // Check against themeMap (simple exact match for now)
                if (window.themeMap[cleanedWord]) {
                  const theme = window.themeMap[cleanedWord];
                  window.dashboardData.topicFrequency[theme] = (window.dashboardData.topicFrequency[theme] || 0) + 1;
                  themed = true;
                }
                
                // If not themed, or if we want to count raw words too:
                if (!themed || true) { // Modify condition if only themed words are needed in wordFrequency
                    window.dashboardData.wordFrequency[cleanedWord] = (window.dashboardData.wordFrequency[cleanedWord] || 0) + 1;
                }
              });
            }
          });
        }
        
        const customerPhone = call.meta["Customer phone number / email address"];
        if (customerPhone && customerPhone !== "Unknown" && customerPhone !== "N/A") {
          if (!window.dashboardData.repeatCallers[customerPhone]) {
            window.dashboardData.repeatCallers[customerPhone] = {
              phoneNumber: customerPhone,
              calls: [],
              flagCount: {},
              firstCall: null,
              latestCall: null
            };
          }
          const callerRecord = window.dashboardData.repeatCallers[customerPhone];
          callerRecord.calls.push({
            id: call.meta["Contact ID"],
            timestamp: call.meta["Initiation timestamp"],
            flags: call.flags || [],
            agent: agentName
          });
          if (call.flags) {
            call.flags.forEach(flag => {
              callerRecord.flagCount[flag] = (callerRecord.flagCount[flag] || 0) + 1;
            });
          }
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              if (!callerRecord.firstCall || date < new Date(callerRecord.firstCall)) {
                callerRecord.firstCall = timestamp;
              }
              if (!callerRecord.latestCall || date > new Date(callerRecord.latestCall)) {
                callerRecord.latestCall = timestamp;
              }
            }
          }
        }
        
        if (call.meta["Categories"] && call.meta["Categories"] !== "N/A") {
          const categoryList = call.meta["Categories"].split(',').map(cat => cat.trim());
          categoryList.forEach(category => {
            if (category) {
              window.dashboardData.categories[category] = (window.dashboardData.categories[category] || 0) + 1;
            }
          });
        }
      });
      
      Object.values(window.dashboardData.agents).forEach(agent => {
        agent.avgDuration = agent.totalCalls > 0 ? agent.totalDuration / agent.totalCalls : 0;
      });
    }
    
    function parseDuration(durationText) {
      if (!durationText) return 0;
      
      const timeMatch = durationText.match(/(\d+):(\d+):(\d+)/);
      if (timeMatch) {
        const hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3]);
        return hours * 60 + minutes + seconds / 60;
      }
      
      const textMatch = durationText.match(/(\d+)\s*minutes?\s*(?:and\s*)?(?:(\d+)\s*seconds?)?/i);
      if (textMatch) {
        const minutes = parseInt(textMatch[1] || 0);
        const seconds = parseInt(textMatch[2] || 0);
        return minutes + seconds / 60;
      }
      
      const num = parseFloat(durationText);
      if (!isNaN(num)) return num;
      
      return 0;
    }
    
    function refreshDashboard() {
      if (!window.dashboardData.calls || window.dashboardData.calls.length === 0) {
        dataStatus.textContent = "No data loaded to refresh.";
        window.dashboardData.loaded = false;
        clearDashboardElements();
        return;
      }

      dataStatus.textContent = "üîÑ Re-processing and refreshing dashboard with filter...";
      processData();
      window.dashboardData.loaded = true;
      
      if (window.dashboardData.filteredCalls.length === 0 && (getSelectedAgentsFromFilter().length > 0 && !getSelectedAgentsFromFilter().includes('all'))) {
        dataStatus.textContent = `‚ö†Ô∏è No calls match the current agent filter. Loaded ${window.dashboardData.calls.length} total calls.`;
        clearDashboardElements();
        const activeButtonNoData = document.querySelector('.tab-button.active');
        if (activeButtonNoData) {
            renderActiveTabContent(activeButtonNoData.dataset.tab);
        } else if (tabButtons.length > 0) {
            tabButtons[0].click();
        }
        return;
      }
      
      updateSummaryStats();

      const activeButton = document.querySelector('.tab-button.active');
      if (activeButton) {
          renderActiveTabContent(activeButton.dataset.tab);
      } else if (tabButtons.length > 0) {
          tabButtons[0].click(); 
      }
      dataStatus.textContent = `‚úÖ Dashboard refreshed. Displaying ${window.dashboardData.filteredCalls.length} of ${window.dashboardData.calls.length} calls based on filter.`;
    }
    
    function clearDashboardElements() {
        document.getElementById('totalCalls').textContent = '0';
        document.getElementById('flaggedCalls').textContent = '0';
        document.getElementById('positiveCalls').textContent = '0';
        document.getElementById('avgDuration').textContent = '0 min';

        if (agentPerformanceChart) agentPerformanceChart.destroy();
        if (flagDistributionChart) flagDistributionChart.destroy();
        if (positiveIndicatorsChartActual) positiveIndicatorsChartActual.destroy();
        if (timeDistributionChart) timeDistributionChart.destroy();
        if (dayDistributionChart) dayDistributionChart.destroy();
        if (channelDistributionChart) channelDistributionChart.destroy();
        if (queueDistributionChart) queueDistributionChart.destroy();
        if (categoriesChart) categoriesChart.destroy();
        if (callbackVolumeChart) callbackVolumeChart.destroy();
        if (agentRepeatCountsChart) agentRepeatCountsChart.destroy();
        if (repeatThemesPieChart) repeatThemesPieChart.destroy();
        agentPerformanceChart = flagDistributionChart = positiveIndicatorsChartActual = timeDistributionChart = null;
        dayDistributionChart = channelDistributionChart = queueDistributionChart = categoriesChart = null;
        callbackVolumeChart = null;
        agentRepeatCountsChart = null;
        repeatThemesPieChart = null;

        const noDataMsg = '<td colspan="5" class="no-data-message">No data available</td>';
        const originalRepeatCallersBody = document.getElementById('repeatCallersBodyOriginalLocation');
        if (originalRepeatCallersBody) originalRepeatCallersBody.innerHTML = `<tr>${noDataMsg}</tr>`;
        document.getElementById('repeatCallersBody').innerHTML = `<tr>${noDataMsg}</tr>`;
        
        document.getElementById('commonTopics').innerHTML = '<div class="no-data-message">No data available</div>';
        document.getElementById('categoryDetails').innerHTML = '<div class="no-data-message">No categories data available</div>';
        
        const originalTopAgentsBody = document.getElementById('topAgentsBodyOriginalLocation');
        if (originalTopAgentsBody) originalTopAgentsBody.innerHTML = `<tr>${noDataMsg}</tr>`;
        document.getElementById('topAgentsBody').innerHTML = `<tr>${noDataMsg}</tr>`;

        document.getElementById('positiveCallsListActual').innerHTML = '<div class="no-data-message">No data available</div>';
    }
    
    function updateSummaryStats() {
      const totalCalls = window.dashboardData.filteredCalls.length;
      let flaggedCalls = 0;
      let positiveCalls = 0;
      let totalDuration = 0;
      
      window.dashboardData.filteredCalls.forEach(call => {
        if (call.flags && call.flags.length > 0) flaggedCalls++;
        if (call.positiveFlags && call.positiveFlags.length > 0) positiveCalls++;
        
        const durationText = call.meta["Contact duration"] || "0";
        totalDuration += parseDuration(durationText);
      });
      
      const avgDuration = totalCalls > 0 ? totalDuration / totalCalls : 0;
      
      document.getElementById('totalCalls').textContent = totalCalls;
      document.getElementById('flaggedCalls').textContent = flaggedCalls;
      document.getElementById('positiveCalls').textContent = positiveCalls;
      document.getElementById('avgDuration').textContent = avgDuration.toFixed(1) + ' min';
    }
    
    function renderAgentPerformanceChart() {
      const ctx = document.getElementById('agentPerformanceChart').getContext('2d');
      
      const agentsInFilteredSet = {};
      window.dashboardData.filteredCalls.forEach(call => {
          const agentName = call.meta["Agent name"] || call.meta["Agent"] || "Unknown";
          if (!agentsInFilteredSet[agentName]) {
              agentsInFilteredSet[agentName] = { name: agentName, totalCalls: 0, flaggedCalls: 0, positiveCalls: 0 };
          }
          agentsInFilteredSet[agentName].totalCalls++;
          if (call.flags && call.flags.length > 0) agentsInFilteredSet[agentName].flaggedCalls++;
          if (call.positiveFlags && call.positiveFlags.length > 0) agentsInFilteredSet[agentName].positiveCalls++;
      });
      
      const agents = Object.values(agentsInFilteredSet)
        .sort((a, b) => b.totalCalls - a.totalCalls)
        .slice(0, 10);
      
      if (agentPerformanceChart) {
        agentPerformanceChart.destroy();
      }
      
      agentPerformanceChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: agents.map(a => a.name),
          datasets: [
            {
              label: 'Positive Calls',
              data: agents.map(a => a.positiveCalls),
              backgroundColor: agents.map((a, index) => window.dashboardData.agentColors[a.name] ? window.dashboardData.agentColors[a.name].replace('0.8', '0.6') : window.COLOR_POOL[(index + window.COLOR_POOL.length -1) % window.COLOR_POOL.length].replace('0.8', '0.6')),
              borderColor: agents.map((a, index) => window.dashboardData.agentColors[a.name] || window.COLOR_POOL[(index + window.COLOR_POOL.length -1) % window.COLOR_POOL.length]),
              borderWidth: 1
            },
            {
              label: 'Neutral Calls',
              data: agents.map(a => a.totalCalls - a.flaggedCalls - a.positiveCalls),
              backgroundColor: agents.map((a, index) => window.dashboardData.agentColors[a.name] ? window.dashboardData.agentColors[a.name].replace('0.8', '0.4') : window.COLOR_POOL[index % window.COLOR_POOL.length].replace('0.8', '0.4')),
              borderColor: agents.map((a, index) => window.dashboardData.agentColors[a.name] || window.COLOR_POOL[index % window.COLOR_POOL.length]),
              borderWidth: 1
            },
            {
              label: 'Flagged Calls',
              data: agents.map(a => a.flaggedCalls),
              backgroundColor: agents.map((a, index) => window.dashboardData.agentColors[a.name] ? window.dashboardData.agentColors[a.name].replace('0.8', '0.9') : window.COLOR_POOL[(index + 1) % window.COLOR_POOL.length].replace('0.8','0.9')),
              borderColor: agents.map((a, index) => window.dashboardData.agentColors[a.name] || window.COLOR_POOL[(index + 1) % window.COLOR_POOL.length]),
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    function renderFlagDistributionChart() {
      const ctx = document.getElementById('flagDistributionChart').getContext('2d');
      
      const localFlags = {};
      window.dashboardData.filteredCalls.forEach(call => {
          if (call.flags) {
              call.flags.forEach(flag => {
                  localFlags[flag] = (localFlags[flag] || 0) + 1;
              });
          }
      });
      
      const topFlags = Object.entries(localFlags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
      
      if (flagDistributionChart) {
        flagDistributionChart.destroy();
      }
      
      flagDistributionChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: topFlags.map(f => f[0]),
          datasets: [{
            label: 'Flag Occurrences',
            data: topFlags.map(f => f[1]),
            backgroundColor: 'rgba(255, 77, 77, 0.7)',
            borderColor: 'rgba(255, 77, 77, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    function renderTimeDistributionCharts() {
      const localHourDistribution = new Array(24).fill(0);
      const localDayDistribution = new Array(7).fill(0);

      window.dashboardData.filteredCalls.forEach(call => {
          try {
            const timestamp = call.meta["Initiation timestamp"];
            if (timestamp) {
              const date = new Date(timestamp);
              if (!isNaN(date.getTime())) {
                localHourDistribution[date.getHours()]++;
                localDayDistribution[date.getDay()]++;
              }
            }
          } catch (error) {
            console.error("Error processing timestamp for filtered time charts:", error);
          }
      });

      const hourCanvas = document.getElementById('timeDistributionChart');
      if (!hourCanvas) {
        console.warn("Hour distribution chart canvas not found");
        return;
      }
      const hourCtx = hourCanvas.getContext('2d');
      
      if (timeDistributionChart) {
        timeDistributionChart.destroy();
      }
      
      const hourLabels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      timeDistributionChart = new Chart(hourCtx, {
        type: 'bar',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Calls by Hour of Day',
            data: localHourDistribution,
            backgroundColor: 'rgba(164, 62, 201, 0.7)',
            borderColor: 'rgba(164, 62, 201, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      const dayCanvas = document.getElementById('dayDistributionChart');
      if (!dayCanvas) {
        console.warn("Day distribution chart canvas not found");
        return;
      }
      const dayCtx = dayCanvas.getContext('2d');
      
      if (dayDistributionChart) {
        dayDistributionChart.destroy();
      }
      
      dayDistributionChart = new Chart(dayCtx, {
        type: 'bar',
        data: {
          labels: DAY_NAMES,
          datasets: [{
            label: 'Calls by Day of Week',
            data: localDayDistribution,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    function renderChannelAndQueueCharts() {
      const localChannelDistribution = {};
      const localQueueDistribution = {};

      window.dashboardData.filteredCalls.forEach(call => {
          const channel = call.meta["Channel"] || "Unknown";
          localChannelDistribution[channel] = (localChannelDistribution[channel] || 0) + 1;
          
          const queue = call.meta["Queue"] || "Unknown";
          localQueueDistribution[queue] = (localQueueDistribution[queue] || 0) + 1;
      });

      const pieChartColors = [
        'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
        'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
        'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)'
      ];

      const channelCanvas = document.getElementById('channelDistributionChart');
      if (!channelCanvas) {
        console.warn("Channel distribution chart canvas not found");
        return;
      }
      const channelCtx = channelCanvas.getContext('2d');
      
      if (channelDistributionChart) {
        channelDistributionChart.destroy();
      }
      
      channelDistributionChart = new Chart(channelCtx, {
        type: 'pie',
        data: {
          labels: Object.keys(localChannelDistribution),
          datasets: [{
            data: Object.values(localChannelDistribution),
            backgroundColor: pieChartColors,
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      const queueCanvas = document.getElementById('queueDistributionChart');
      if (!queueCanvas) {
        console.warn("Queue distribution chart canvas not found");
        return;
      }
      const queueCtx = queueCanvas.getContext('2d');
      
      if (queueDistributionChart) {
        queueDistributionChart.destroy();
      }
      
      queueDistributionChart = new Chart(queueCtx, {
        type: 'pie',
        data: {
          labels: Object.keys(localQueueDistribution),
          datasets: [{
            data: Object.values(localQueueDistribution),
            backgroundColor: pieChartColors.slice().reverse(),
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    function renderCategoriesChart() {
      const canvasElement = document.getElementById('categoriesChart');
      if (!canvasElement) {
        console.warn("Categories chart canvas not found");
        return;
      }
      const ctx = canvasElement.getContext('2d');
      const categoryDetailsContainer = document.getElementById('categoryDetails');
      
      const localCategories = {};
      window.dashboardData.filteredCalls.forEach(call => {
          if (call.meta["Categories"] && call.meta["Categories"] !== "N/A") {
            const categoryList = call.meta["Categories"].split(',').map(cat => cat.trim());
            categoryList.forEach(category => {
              if (category) {
                localCategories[category] = (localCategories[category] || 0) + 1;
              }
            });
          }
      });
      
      const categories = Object.entries(localCategories)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      if (categories.length === 0) {
        if (categoriesChart) categoriesChart.destroy();
        categoriesChart = null;
        categoryDetailsContainer.innerHTML = '<div class="no-data-message">No categories data available for current filter</div>';
        return;
      }
      
      const counts = categories.map(c => c[1]);
      
      const categoryColors = window.COLOR_POOL.slice(0, Math.min(counts.length, window.COLOR_POOL.length)).map(c => c.replace('0.8', '0.7'));
      
      if (categoriesChart) {
        categoriesChart.destroy();
      }
      
      categoriesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: categories.map(c => c[0]),
          datasets: [
            {
              label: 'Call Count',
              data: counts,
              backgroundColor: categoryColors,
              borderColor: categoryColors.map(c => c.replace('0.7', '1')),
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            },
            title: {
              display: true,
              text: 'Top Call Categories',
              color: '#ccc',
              font: {
                size: 16
              }
            }
          }
        }
      });
      
      let detailsHtml = `
        <h3 style="font-size: 16px; margin-bottom: 10px; color: #aaa;">Category Distribution</h3>
        <table style="width: 100%;">
          <thead>
            <tr>
              <th style="text-align: left;">Category</th>
              <th style="text-align: right;">Count</th>
              <th style="text-align: right;">Percentage</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      const totalCalls = window.dashboardData.filteredCalls.length;
      categories.forEach(([category, count]) => {
        const percentage = (count / totalCalls * 100).toFixed(1);
        detailsHtml += `
          <tr>
            <td style="text-align: left;">${category}</td>
            <td style="text-align: right;">${count}</td>
            <td style="text-align: right;">${percentage}%</td>
          </tr>
        `;
      });
      
      detailsHtml += `
          </tbody>
        </table>
      `;
      
      categoryDetailsContainer.innerHTML = detailsHtml;
    }
    
    function updateCommonTopics() {
      const container = document.getElementById('commonTopics');
      container.innerHTML = ''; // Clear previous content

      // Combine themed topics and other frequent words
      const displayItems = [];

      // Add themed topics
      Object.entries(window.dashboardData.topicFrequency)
        .forEach(([theme, count]) => {
          displayItems.push({ text: theme, count: count, isTheme: true });
        });

      // Add other frequent words (that are not part of a theme already counted)
      // This part can be refined. For now, let's just show top words not directly in themes.
      const allThemeWords = Object.keys(window.themeMap);
      Object.entries(window.dashboardData.wordFrequency)
        .filter(([word, count]) => !window.themeMap[word]) // Avoid double counting if word itself is a theme keyword
        .forEach(([word, count]) => {
            // Heuristic: only add if count is significant and not a stop word (already filtered but good check)
             if (count > 2 && word.length > 3) { // Adjust threshold as needed
                displayItems.push({ text: word, count: count, isTheme: false });
            }
        });
        
      displayItems.sort((a, b) => b.count - a.count);
      const topItems = displayItems.slice(0, 40); // Show top 40 combined

      if (topItems.length === 0) {
        const message = document.createElement('div');
        message.className = 'no-data-message';
        message.textContent = 'No common topics or frequent words found.';
        container.appendChild(message);
        return;
      }

      const maxFrequency = topItems.length > 0 ? topItems[0].count : 1;

      topItems.forEach(item => {
        const fontSize = Math.max(12, Math.min(24, 12 + (item.count / maxFrequency) * 12));
        const opacity = 0.6 + (item.count / maxFrequency) * 0.4;

        const element = document.createElement('div');
        element.style.fontSize = `${fontSize}px`;
        element.style.padding = '4px 10px';
        element.style.margin = '4px';
        element.style.borderRadius = '12px';
        element.style.color = '#eee';
        element.title = `${item.count} occurrences`;
        element.textContent = item.text;

        if (item.isTheme) {
          element.style.background = `rgba(164, 62, 201, ${opacity})`; // Purple for themes
          element.style.fontWeight = 'bold';
        } else {
          element.style.background = `rgba(255, 255, 255, ${opacity * 0.15})`; // Lighter for individual words
        }
        container.appendChild(element);
      });
    }
    
    function updateTopAgentsTable() {
      const tableBody = document.getElementById('topAgentsBody');
      if(!tableBody) {
        console.warn("Top agents table body not found. Original or new.");
        return;
      }
      const agentsInFilteredSetForTable = {};
       window.dashboardData.filteredCalls.forEach(call => {
          const agentName = call.meta["Agent name"] || call.meta["Agent"] || "Unknown";
          if (!agentsInFilteredSetForTable[agentName]) {
              agentsInFilteredSetForTable[agentName] = { 
                  name: agentName, totalCalls: 0, positiveCalls: 0, positiveScore: 0, totalDuration: 0 
              };
          }
          const agentData = agentsInFilteredSetForTable[agentName];
          agentData.totalCalls++;
          if (call.positiveFlags && call.positiveFlags.length > 0) agentData.positiveCalls++;
          agentData.positiveScore += (call.positiveScore || 0);
          agentData.totalDuration += parseDuration(call.meta["Contact duration"] || "0");
      });

      const sortedAgents = Object.values(agentsInFilteredSetForTable)
        .map(agent => {
          const positiveRatio = agent.totalCalls > 0 ? 
            (agent.positiveCalls / agent.totalCalls) : 0;
          const avgScore = agent.totalCalls > 0 ? 
            (agent.positiveScore / agent.totalCalls) : 0;
          const avgDuration = agent.totalCalls > 0 ?
            (agent.totalDuration / agent.totalCalls) :0;
            
          return {
            ...agent,
            positiveRatio,
            avgScore,
            avgDuration
          };
        })
        .sort((a, b) => b.avgScore - a.avgScore)
        .slice(0, 5);
      
      tableBody.innerHTML = '';
      
      if (sortedAgents.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" class="no-data-message">No data available</td>';
        tableBody.appendChild(row);
        return;
      }
      
      sortedAgents.forEach(agent => {
        const row = document.createElement('tr');
        
        row.innerHTML = `
          <td>${agent.name}</td>
          <td>${agent.totalCalls}</td>
          <td>${(agent.positiveRatio * 100).toFixed(1)}%</td>
          <td>${agent.avgScore.toFixed(2)}</td>
          <td>${agent.avgDuration.toFixed(1)} min</td>
        `;
        
        tableBody.appendChild(row);
      });
    }
    
    function renderPositiveIndicatorsChartActual() {
      console.log("[Debug] renderPositiveIndicatorsChartActual called with filtered data");
      const localPositiveFlags = {};
      window.dashboardData.filteredCalls.forEach(call => {
          if (call.positiveFlags) {
              call.positiveFlags.forEach(flag => { localPositiveFlags[flag] = (localPositiveFlags[flag] || 0) + 1; });
          }
      });
      console.log("[Debug] localPositiveFlags (from filtered):", JSON.parse(JSON.stringify(localPositiveFlags)));

      const canvasElement = document.getElementById('positiveIndicatorsChartActual');
      if (!canvasElement) {
        console.warn("Positive Indicators chart canvas not found");
        return;
      }
      const ctx = canvasElement.getContext('2d');
      
      const topPositiveFlags = Object.entries(localPositiveFlags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      const labels = topPositiveFlags.map(f => f[0]);
      const data = topPositiveFlags.map(f => f[1]);

      if (positiveIndicatorsChartActual) {
        positiveIndicatorsChartActual.destroy();
      }
      
      positiveIndicatorsChartActual = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Positive Indicator Occurrences',
            data: data,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#ccc',
                stepSize: Math.max(1, Math.ceil(Math.max(...data) / 10))
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            },
            title: {
                display: true,
                text: 'Top Positive Indicators',
                color: '#ccc',
                font: {
                    size: 16
                }
            }
          }
        }
      });
    }
    
    function updatePositiveCallsListActual() {
        console.log("[Debug] updatePositiveCallsListActual called with filtered data");
        const positiveCallsSource = window.dashboardData.filteredCalls.filter(call => call.positiveScore > 0);
        console.log("[Debug] Calls with positiveScore > 0 (from filtered):", JSON.parse(JSON.stringify(positiveCallsSource)));

        const container = document.getElementById('positiveCallsListActual');
        if (!container) {
            console.warn('Container for actual positive calls list not found.');
            return;
        }

        container.innerHTML = '';

        if (positiveCallsSource.length === 0) {
            const message = document.createElement('div');
            message.className = 'no-data-message';
            message.textContent = 'No positive calls available';
            container.appendChild(message);
            return;
        }

        positiveCallsSource.forEach(call => {
            const agent = call.meta["Agent name"] || call.meta["Agent"] || "Unknown";
            const date = call.meta["Initiation timestamp"] || "Unknown date";
            const duration = call.meta["Contact duration"] || "Unknown";

            const callElement = document.createElement('div');
            callElement.style.margin = '0 0 15px 0';
            callElement.style.padding = '10px';
            callElement.style.background = 'rgba(76, 175, 80, 0.05)';
            callElement.style.borderLeft = '3px solid #4caf50';

            callElement.innerHTML = `
              <div><strong>${agent}</strong> - ${new Date(date).toLocaleString()} - Duration: ${duration}</div>
              <div>Positive Score: <span class="positive-color">${call.positiveScore}</span></div>
              <div>
                ${call.positiveFlags.map(flag =>
                `<span style="display: inline-block; margin: 3px; padding: 2px 6px; background: rgba(76, 175, 80, 0.1); border-radius: 3px; color: #4caf50;">${flag}</span>`
            ).join('')}
              </div>
              ${call.summary ? `<div style="margin-top: 5px; font-style: italic; color: #aaa;">${call.summary}</div>` : ''}
            `;

            container.appendChild(callElement);
        });
    }

    function getSelectedAgentsFromFilter() {
        if (!agentFilterElement) return ['all'];
        return [...agentFilterElement.selectedOptions].map(option => option.value);
    }

    function handleAgentFilterChange(selectedAgents) {
        console.log("Agent filter changed, selected:", selectedAgents);
        localStorage.setItem('selectedAgents', JSON.stringify(selectedAgents));
        refreshDashboard();
    }

    // New function for Top 5 Flags on Insights Tab
    function renderTopFlagsChartInsights() {
      const ctx = document.getElementById('topFlagsChartInsights')?.getContext('2d');
      if (!ctx) return;

      const localFlags = {};
      window.dashboardData.filteredCalls.forEach(call => {
          if (call.flags) {
              call.flags.forEach(flag => {
                  localFlags[flag] = (localFlags[flag] || 0) + 1;
              });
          }
      });
      
      const topFlags = Object.entries(localFlags)
        .sort(([,a],[,b]) => b-a)
        .slice(0, 5);

      if (topFlagsChartInsights) {
        topFlagsChartInsights.destroy();
      }
      
      topFlagsChartInsights = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: topFlags.map(f => f[0]),
          datasets: [{
            label: 'Flag Occurrences',
            data: topFlags.map(f => f[1]),
            backgroundColor: 'rgba(255, 77, 77, 0.7)',
            borderColor: 'rgba(255, 77, 77, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // Horizontal bar chart
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { color: '#ccc', stepSize: 1 },
              grid: { color: 'rgba(255, 255, 255, 0.05)' }
            },
            y: {
              ticks: { color: '#ccc' },
              grid: { color: 'rgba(255, 255, 255, 0.05)' }
            }
          },
          plugins: {
            legend: { display: false },
            title: { display: false }
          }
        }
      });
    }

    // New function for Top 5 Positive Indicators on Insights Tab
    function renderTopPositiveIndicatorsChartInsights() {
      const ctx = document.getElementById('topPositiveIndicatorsChartInsights')?.getContext('2d');
      if (!ctx) return;

      const localPositiveFlags = {};
      window.dashboardData.filteredCalls.forEach(call => {
          if (call.positiveFlags) {
              call.positiveFlags.forEach(flag => { 
                  localPositiveFlags[flag] = (localPositiveFlags[flag] || 0) + 1; 
              });
          }
      });
      
      const topPositiveIndicators = Object.entries(localPositiveFlags)
        .sort(([,a],[,b]) => b-a)
        .slice(0, 5);

      if (topPositiveIndicatorsChartInsights) {
        topPositiveIndicatorsChartInsights.destroy();
      }
      
      topPositiveIndicatorsChartInsights = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: topPositiveIndicators.map(f => f[0]),
          datasets: [{
            label: 'Indicator Occurrences',
            data: topPositiveIndicators.map(f => f[1]),
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // Horizontal bar chart
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { color: '#ccc', stepSize: 1 },
              grid: { color: 'rgba(255, 255, 255, 0.05)' }
            },
            y: {
              ticks: { color: '#ccc' },
              grid: { color: 'rgba(255, 255, 255, 0.05)' }
            }
          },
          plugins: {
            legend: { display: false },
            title: { display: false }
          }
        }
      });
    }

    // New function for Flag/Positive Trends Line Chart
    function renderFlagPositiveTrendsChart() {
      const ctx = document.getElementById('flagPositiveTrendsChart')?.getContext('2d');
      if (!ctx) return;

      const sortedDates = Object.keys(window.dashboardData.dailyFlagCounts).sort();
      
      if (sortedDates.length === 0) {
        if (flagPositiveTrendsChart) flagPositiveTrendsChart.destroy();
        flagPositiveTrendsChart = null;
        // Optionally, display a no-data message in the canvas container
        return;
      }

      const flagCounts = sortedDates.map(date => window.dashboardData.dailyFlagCounts[date] || 0);
      const positiveCounts = sortedDates.map(date => window.dashboardData.dailyPositiveCounts[date] || 0);

      if (flagPositiveTrendsChart) {
        flagPositiveTrendsChart.destroy();
      }

      flagPositiveTrendsChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: sortedDates,
          datasets: [
            {
              label: 'Total Flagged Calls',
              data: flagCounts,
              borderColor: 'rgba(255, 77, 77, 0.8)',
              backgroundColor: 'rgba(255, 77, 77, 0.2)',
              fill: true,
              tension: 0.1
            },
            {
              label: 'Total Positive Indicator Calls',
              data: positiveCounts,
              borderColor: 'rgba(76, 175, 80, 0.8)',
              backgroundColor: 'rgba(76, 175, 80, 0.2)',
              fill: true,
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { color: '#ccc' },
              grid: { color: 'rgba(255, 255, 255, 0.05)' }
            },
            y: {
              ticks: { color: '#ccc', beginAtZero: true, stepSize: 1 },
              grid: { color: 'rgba(255, 255, 255, 0.05)' }
            }
          },
          plugins: {
            legend: { labels: { color: '#ccc' } },
            title: { display: false }
          }
        }
      });
    }

    function updateAgentPerformanceSnapshots() {
      const container = document.getElementById('agentSnapshotsContainer');
      if (!container) {
        console.warn("Agent snapshots container not found.");
        return;
      }

      container.innerHTML = '';

      const selectedAgents = getSelectedAgentsFromFilter();
      const selectedAgentsData = [];

      window.dashboardData.filteredCalls.forEach(call => {
        const agentName = call.meta["Agent name"] || call.meta["Agent"] || "Unknown";
        if (selectedAgents.includes(agentName)) {
          if (!selectedAgentsData.some(data => data.name === agentName)) {
            selectedAgentsData.push({
              name: agentName,
              totalCalls: 0,
              flaggedCalls: 0,
              positiveCalls: 0,
              positiveScore: 0,
              avgDuration: 0,
              totalDuration: 0,
              softSkills: {} // Initialize soft skills for the agent
            });
          }

          const agentData = selectedAgentsData.find(data => data.name === agentName);
          agentData.totalCalls++;
          agentData.totalDuration += parseDuration(call.meta["Contact duration"] || "0");
          agentData.positiveScore += (call.positiveScore || 0);

          // Aggregate soft skills for specific selected agent
          const callTextForSkillsSpecific = (call.transcript || []).map(entry => entry.text || '').join(' ').toLowerCase();
          const callPositiveFlagsSpecific = call.positiveFlags || [];
          Object.keys(window.softSkillKeywordMap).forEach(skill => {
            if (!agentData.softSkills[skill]) agentData.softSkills[skill] = 0;
            window.softSkillKeywordMap[skill].forEach(keyword => {
              if (callTextForSkillsSpecific.includes(keyword)) agentData.softSkills[skill]++;
              if (callPositiveFlagsSpecific.includes(keyword)) agentData.softSkills[skill]++;
            });
          });

          if (call.flags && call.flags.length > 0) {
            agentData.flaggedCalls++;
            call.flags.forEach(flag => {
              agentData.flagCount[flag] = (agentData.flagCount[flag] || 0) + 1;
            });
          }

          if (call.positiveFlags && call.positiveFlags.length > 0) {
            agentData.positiveCalls++;
            call.positiveFlags.forEach(flag => {
              agentData.positiveFlagCount[flag] = (agentData.positiveFlagCount[flag] || 0) + 1;
            });
          }

          // Aggregate soft skills for snapshot if 'all' agents are shown
          const callTextForSkillsAll = (call.transcript || []).map(entry => entry.text || '').join(' ').toLowerCase();
          const callPositiveFlagsAll = call.positiveFlags || [];
          Object.keys(window.softSkillKeywordMap).forEach(skill => {
            if (!agentData.softSkills[skill]) agentData.softSkills[skill] = 0;
            window.softSkillKeywordMap[skill].forEach(keyword => {
              if (callTextForSkillsAll.includes(keyword)) agentData.softSkills[skill]++;
              if (callPositiveFlagsAll.includes(keyword)) agentData.softSkills[skill]++;
            });
          });
        }
      });

      selectedAgentsData.forEach(data => {
        const card = document.createElement('div');
        card.className = 'dashboard-card';
        card.style.background = '#2a2a2a';
        card.style.borderRadius = '5px';
        card.style.padding = '20px';
        card.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';

        card.innerHTML = `
          <div class="card-header">
            <span>${data.name}</span>
          </div>
          <div class="stat-grid">
            <div class="stat-card">
              <div class="stat-label">Total Calls</div>
              <div class="stat-value">${data.totalCalls}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Flagged Calls</div>
              <div class="stat-value negative-color">${data.flaggedCalls}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Positive Calls</div>
              <div class="stat-value positive-color">${data.positiveCalls}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Avg. Call Duration</div>
              <div class="stat-value">${(data.totalDuration / data.totalCalls).toFixed(1)} min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Avg. Positive Score</div>
              <div class="stat-value positive-color">${(data.positiveScore / data.totalCalls).toFixed(2)}</div>
            </div>
          </div>
          <div class="stat-grid">
            <div class="stat-card">
              <div class="stat-label">Top Flags</div>
              <div class="stat-value">${Object.entries(data.flagCount || {})
                .sort(([,a],[,b]) => b-a)
                .slice(0, 3)
                .map(([name, count]) => `<span class="snapshot-tag snapshot-tag-flag">${name} (${count})</span>`)
                .join(' ')}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Top Positive Mentions</div>
              <div class="stat-value positive-color">${Object.entries(data.positiveFlagCount || {})
                .sort(([,a],[,b]) => b-a)
                .slice(0, 3)
                .map(([name, count]) => `<span class="snapshot-tag snapshot-tag-positive">${name} (${count})</span>`)
                .join(' ')}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Soft Skills</div>
              <div class="stat-value">${Object.entries(data.softSkills || {})
                .filter(([skill, score]) => score > 0)
                .map(([skill, score]) => `<span class="snapshot-tag">${skill}: ${score}</span>`)
                .join(' ')}</div>
            </div>
          </div>
        `;

        container.appendChild(card);
      });
    }
  </script>
</body>
</html>
