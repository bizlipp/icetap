<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inspiro Analytics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    .corporate-header {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      padding: 15px;
      background: #1e1e1e;
      border-radius: 5px;
    }
    .dashboard-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .dashboard-card {
      background: #222;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .card-header {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .accent-color {
      color: #a43ec9;
    }
    .positive-color {
      color: #4caf50;
    }
    .negative-color {
      color: #ff4d4d;
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    .stat-card {
      background: #2a2a2a;
      border-radius: 5px;
      padding: 15px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .stat-label {
      font-size: 14px;
      color: #aaa;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    th {
      background-color: #2a2a2a;
      color: #ccc;
    }
    .data-controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #222;
      border-radius: 5px;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    button {
      padding: 8px 15px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .primary-button {
      background: #a43ec9;
      border-color: #a43ec9;
    }
    button:hover {
      background: #444 !important;
    }
    .primary-button:hover {
      background: #b44dd9 !important;
      border-color: #b44dd9;
    }
    .no-data-message {
      text-align: center;
      padding: 30px;
      color: #888;
      font-style: italic;
    }

    /* Tab System Styles */
    .tab-navigation {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #333; /* Separator for tabs */
    }

    .tab-button {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #222; /* Darker, inactive tab */
      color: #aaa;
      border: none;
      border-bottom: 3px solid transparent; /* For active indicator */
      margin-right: 5px;
      transition: background-color 0.3s, color 0.3s, border-bottom 0.3s;
      font-size: 16px;
      border-top-left-radius: 5px; /* Rounded corners for tabs */
      border-top-right-radius: 5px;
    }

    .tab-button:hover {
      background-color: #333 !important; /* Consistent hover with other buttons */
      color: #fff !important;
    }

    .tab-button.active {
      background-color: #1a1a1a !important; /* Match body background for seamless look */
      color: #a43ec9 !important; /* Accent color for active tab text */
      border-bottom: 3px solid #a43ec9; /* Accent color indicator */
      font-weight: bold;
    }

    .tab-content {
      display: none;
      padding-top: 20px; /* Space between tab nav and content */
      animation: fadeIn 0.5s; /* Simple fade-in animation */
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* End Tab System Styles */
  </style>
</head>
<body>
  <div class="corporate-header">
    <h1 style="font-family: Arial, sans-serif;">
      <span style="color: #000; font-size: 42px; font-weight: 900;">inspi</span><span style="color: #a43ec9; font-size: 42px; font-weight: 900;">r</span><span style="color: #000; font-size: 42px; font-weight: 900;">o</span> <span style="font-size: 28px; font-weight: bold;">Analytics Dashboard</span>
    </h1>
    <p>Comprehensive analytics of call transcripts for enhanced customer service performance.</p>
  </div>

  <div class="data-controls">
    <button id="loadDataButton" class="primary-button">Load Data from Parser</button>
    <button id="refreshButton">Refresh Dashboard</button>
    <div id="dataStatus">No data loaded</div>
  </div>

  <div class="tab-navigation">
    <button class="tab-button active" data-tab="overviewTab">üìä Overview</button>
    <button class="tab-button" data-tab="distributionTab">üìà Distribution Analysis</button>
    <button class="tab-button" data-tab="insightsTab">üë• Agent & Caller Insights</button>
    <button class="tab-button" data-tab="positiveTab">üåü Positive Performance</button>
    <button class="tab-button" data-tab="repeatCallersTab">üîÅ Repeat Callers</button>
    <button class="tab-button" data-tab="coachingTab">üß† Coaching & Follow-up</button>
    <button class="tab-button" data-tab="reportsTab">üìã Reports & Export</button>
  </div>

  <div id="overviewTab" class="tab-content active">
    <div class="dashboard-card" id="filtersCard">
      <div class="card-header">
        <span>‚öôÔ∏è Filters</span>
      </div>
      <div style="padding: 15px;">
        <label for="agentFilterSelect" style="display: block; margin-bottom: 8px; font-weight: bold;">Filter by Agent(s):</label>
        <select multiple id="agentFilterSelect" style="width: 100%; min-height: 100px; background: #2c2c2c; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 5px;">
          <!-- Options will be populated by JavaScript -->
        </select>
        <button id="applyAgentFilterButton" class="primary-button" style="margin-top: 10px;">Apply Filter</button>
        <button id="clearAgentFilterButton" style="margin-top: 10px; margin-left: 10px;">Clear Filter</button>
      </div>
    </div>

    <div class="dashboard-container">
      <!-- Summary Statistics -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Call Statistics Summary</span>
        </div>
        <div class="stat-grid">
          <div class="stat-card">
            <div class="stat-label">Total Calls</div>
            <div class="stat-value" id="totalCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Flagged Calls</div>
            <div class="stat-value negative-color" id="flaggedCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Positive Calls</div>
            <div class="stat-value positive-color" id="positiveCalls">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Avg. Call Duration</div>
            <div class="stat-value" id="avgDuration">0 min</div>
          </div>
        </div>
      </div>

      <!-- Agent Performance -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üë• Agent Performance</span>
        </div>
        <div class="chart-container">
          <canvas id="agentPerformanceChart"></canvas>
        </div>
      </div>

      <!-- Flag Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üö© Flag Distribution</span>
        </div>
        <div class="chart-container">
          <canvas id="flagDistributionChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div id="distributionTab" class="tab-content">
    <div class="dashboard-container">
      <!-- Positive Indicators (Moving to Positive Tab later, placeholder for structure) -->
      <!-- This card will be moved. Keeping structure for now. -->
      <div class="dashboard-card" style="display:none;" id="positiveIndicatorsCardPlaceholder">
        <div class="card-header">
          <span>üåü Positive Indicators (Placeholder)</span>
        </div>
        <div class="chart-container">
          <canvas id="positiveIndicatorsChart"></canvas>
        </div>
      </div>

      <!-- Time Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>‚è∞ Call Time Distribution</span>
        </div>
        <div class="chart-container">
          <canvas id="timeDistributionChart"></canvas>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
          <canvas id="dayDistributionChart"></canvas>
        </div>
      </div>
      
      <!-- Channel & Queue Distribution -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üì± Channel & Queue Distribution</span>
        </div>
        <div style="display: flex; gap: 20px;">
          <div style="flex: 1;">
            <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Channels</h3>
            <div class="chart-container" style="height: 200px;">
              <canvas id="channelDistributionChart"></canvas>
            </div>
          </div>
          <div style="flex: 1;">
            <h3 style="font-size: 16px; color: #aaa; margin-bottom: 10px;">Queues</h3>
            <div class="chart-container" style="height: 200px;">
              <canvas id="queueDistributionChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="dashboard-container">
      <!-- Categories Analysis -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìä Categories Analysis</span>
        </div>
        <div class="chart-container">
          <canvas id="categoriesChart"></canvas>
        </div>
        <div id="categoryDetails" style="margin-top: 15px; padding: 10px;">
          <div class="no-data-message">No categories data available</div>
        </div>
      </div>
    </div>
  </div>

  <div id="insightsTab" class="tab-content">
    <div class="dashboard-container">
      <!-- Repeat Callers Analysis - This will be moved -->
      <div class="dashboard-card" id="repeatCallersCardOriginalLocation" style="display:none;"> 
        <div class="card-header">
          <span>üîÅ Repeat Callers Analysis (Original Location - Hidden)</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Customer Phone</th>
              <th>Call Count</th>
              <th>Latest Call</th>
              <th>First Call</th>
              <th>Common Flags</th>
            </tr>
          </thead>
          <tbody id="repeatCallersBodyOriginalLocation">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- Common Topics -->
      <div class="dashboard-card">
        <div class="card-header">
          <span>üîç Common Topics</span>
        </div>
        <div id="commonTopics" style="padding: 10px; display: flex; flex-wrap: wrap; gap: 8px;">
          <div class="no-data-message">No data available</div>
        </div>
      </div>
    </div>
    
    <div class="dashboard-container">
      <!-- Top Agents Table - This will be moved -->
      <div class="dashboard-card" id="topAgentsCardOriginalLocation" style="display:none;">
        <div class="card-header">
          <span>üèÜ Top Performing Agents (Original Location - Hidden)</span>
        </div>
        <table id="topAgentsTableOriginalLocation">
          <thead>
            <tr>
              <th>Agent</th>
              <th>Total Calls</th>
              <th>Positive Ratio</th>
              <th>Avg Score</th>
              <th>Avg Duration</th>
            </tr>
          </thead>
          <tbody id="topAgentsBodyOriginalLocation">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- Recent Positive Calls (Moving to Positive Tab later, placeholder for structure)-->
      <div class="dashboard-card" style="display:none;" id="recentPositiveCallsPlaceholder">
        <div class="card-header">
          <span>‚úÖ Recent Positive Calls (Placeholder)</span>
        </div>
        <div id="positiveCallsList">
          <div class="no-data-message">No data available</div>
        </div>
      </div>
    </div>
  </div>

  <div id="positiveTab" class="tab-content">
    <div class="dashboard-container">
        <!-- Positive Indicators -->
        <div class="dashboard-card" id="positiveIndicatorsCardActual">
            <div class="card-header">
                <span>üåü Positive Indicators</span>
            </div>
            <div class="chart-container">
                <canvas id="positiveIndicatorsChartActual"></canvas> 
            </div>
        </div>
        <!-- Recent Positive Calls -->
        <div class="dashboard-card" id="recentPositiveCallsActual">
            <div class="card-header">
                <span>‚úÖ Recent Positive Calls</span>
            </div>
            <div id="positiveCallsListActual" style="max-height: 400px; overflow-y: auto;"> 
                <div class="no-data-message">No data available</div>
            </div>
        </div>
        <!-- Top Performing Agents - Moved Here -->
        <div class="dashboard-card" id="topAgentsCardMoved">
          <div class="card-header">
            <span>üèÜ Top Performing Agents</span>
          </div>
          <table id="topAgentsTable">
            <thead>
              <tr>
                <th>Agent</th>
                <th>Total Calls</th>
                <th>Positive Ratio</th>
                <th>Avg Score</th>
                <th>Avg Duration</th>
              </tr>
            </thead>
            <tbody id="topAgentsBody">
              <tr>
                <td colspan="5" class="no-data-message">No data available</td>
              </tr>
            </tbody>
          </table>
        </div>
    </div>
  </div> <!-- End of positiveTab -->

  <!-- New Tab: Repeat Caller Analytics -->
  <div id="repeatCallersTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üîÅ Repeat Callers Analysis</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Customer Phone</th>
              <th>Call Count</th>
              <th>Latest Call</th>
              <th>First Call</th>
              <th>Common Flags</th>
            </tr>
          </thead>
          <tbody id="repeatCallersBody">
            <tr>
              <td colspan="5" class="no-data-message">No data available</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div> <!-- End of repeatCallersTab -->

  <!-- New Tab: Coaching & Follow-up -->
  <div id="coachingTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üß† Coaching & Follow-up</span>
        </div>
        <div style="padding: 20px;">
          <p>Coaching plans, follow-up actions, and agent development tools will be available here in a future update.</p>
          <p><em>Stay tuned!</em></p>
        </div>
      </div>
    </div>
  </div> <!-- End of coachingTab -->

  <!-- New Tab: Reports & Export -->
  <div id="reportsTab" class="tab-content">
    <div class="dashboard-container">
      <div class="dashboard-card">
        <div class="card-header">
          <span>üìã Reports & Export</span>
        </div>
        <div style="padding: 20px;">
          <p>Advanced report generation, data export configurations, and distribution options will be available here.</p>
          <p><em>Coming soon!</em></p>
        </div>
      </div>
    </div>
  </div> <!-- End of reportsTab -->

  <script type="module" src="js/agentFilterManager.js"></script> 
  <script>
    // Dashboard state
    let dashboardData = {
      calls: [], // Raw, unfiltered calls
      filteredCalls: [], // Calls filtered by agent selection
      agents: {},
      flags: {},
      positiveFlags: {},
      hourDistribution: new Array(24).fill(0),
      dayDistribution: new Array(7).fill(0),
      channelDistribution: {},
      queueDistribution: {},
      wordFrequency: {},
      repeatCallers: {},
      categories: {},
      agentColors: {}, // For Agent Color Palette Quick Win
      loaded: false
    };
    
    // DOM elements
    const loadDataButton = document.getElementById('loadDataButton');
    const refreshButton = document.getElementById('refreshButton');
    const dataStatus = document.getElementById('dataStatus');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    // Agent Filter UI elements will be grabbed in DOMContentLoaded

    // Chart objects
    let agentPerformanceChart = null;
    let flagDistributionChart = null;
    let positiveIndicatorsChartActual = null; // New chart instance for the "Positive" tab
    let timeDistributionChart = null;
    let dayDistributionChart = null;
    let channelDistributionChart = null;
    let queueDistributionChart = null;
    let categoriesChart = null;
    
    // Constants
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    
    // import functions from agentFilterManager
    import { initAgentFilter, populateAgentFilter, getSelectedAgents, getInitialSelectedAgents } from './js/agentFilterManager.js';

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      const agentFilterSelect = document.getElementById('agentFilterSelect');
      const applyAgentFilterButton = document.getElementById('applyAgentFilterButton');
      const clearAgentFilterButton = document.getElementById('clearAgentFilterButton');
      
      initAgentFilter(agentFilterSelect, applyAgentFilterButton, clearAgentFilterButton, handleFilterChange);

      loadDataButton.addEventListener('click', loadDataFromParser);
      refreshButton.addEventListener('click', refreshDashboard);

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          button.classList.add('active');
          const activeTabId = button.dataset.tab;
          document.getElementById(activeTabId).classList.add('active');
          
          // Render or update content for the newly active tab
          if (dashboardData.loaded) {
            renderActiveTabContent(activeTabId);
          }
        });
      });

      // Automatically try to load data and activate the first tab
      loadDataFromParser().then(() => {
        if (tabButtons.length > 0 && !document.querySelector('.tab-button.active')) {
            tabButtons[0].click(); // Activate the first tab if none is active
        }
      }); 
    });
    
    // Callback function for when agent filter is applied or cleared
    function handleFilterChange(selectedAgents) {
        console.log("Filter changed, selected agents:", selectedAgents);
        // Re-process data with new filter and refresh dashboard
        if (dashboardData.calls.length > 0) { // Only if raw data exists
            applyFiltersAndRefresh();
        }
    }
    
    function applyFiltersAndRefresh() {
        const selectedAgents = getSelectedAgents(); // Get current selection from UI/localStorage via manager

        if (selectedAgents.length > 0) {
            dashboardData.filteredCalls = dashboardData.calls.filter(call => {
                const agentName = call.meta["Agent"] || call.meta["Agent name"];
                return agentName && selectedAgents.includes(agentName);
            });
        } else {
            dashboardData.filteredCalls = [...dashboardData.calls]; // No filter, use all calls
        }
        console.log(`Applied filters. ${dashboardData.filteredCalls.length} calls in filteredCalls.`);
        
        // Now, re-process statistics based on filteredCalls FOR DISPLAY PURPOSES
        // Note: dashboardData.agents (for filter population) and .calls (raw) should remain untouched by this display-filtering.
        // The processDataForDisplay function will populate specific structures for charts/tables from filteredCalls.
        processDataForDisplay(); 
        
        // Full refresh of UI elements
        dashboardData.loaded = true; // Ensure loaded is true if we have filtered calls
        refreshDashboard(); // This will use the new dashboardData.filteredCalls for rendering
    }

    // Load data from localStorage
    async function loadDataFromParser() {
      dataStatus.textContent = "Attempting to load data...";
      dashboardData.loaded = false; 
      try {
        // Try to get data from localStorage
        const storedData = localStorage.getItem('inspiroCallData');
        
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            if (Array.isArray(parsedData) && parsedData.length > 0) {
              dashboardData.calls = parsedData; // Store raw data
              // Initial processing of raw data to get all agents for filter population
              processRawCallDataForAgentsAndColors(); 
              populateAgentFilter(dashboardData.agents); // Populate filter with ALL agents

              // Apply initial filter from localStorage or default to all
              applyFiltersAndRefresh();
              // dataStatus.textContent set by applyFiltersAndRefresh or refreshDashboard
              return;
            }
          } catch (parseError) {
            console.error("Error parsing stored data:", parseError);
          }
        }
        
        dataStatus.textContent = "No data found. Please parse calls in the main tool first.";
      } catch (error) {
        dataStatus.textContent = `‚ùå Error: ${error.message}`;
        console.error(error);
      }
    }
    
    // New function to process raw call data just for agent list and colors
    function processRawCallDataForAgentsAndColors() {
        dashboardData.agents = {}; // Reset agents for fresh population
        dashboardData.calls.forEach(call => {
            const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
            if (!dashboardData.agents[agent]) {
                dashboardData.agents[agent] = { name: agent, totalCalls: 0 }; // Basic structure for now
            }
            dashboardData.agents[agent].totalCalls++;
        });

        // Agent Color Palette Quick Win
        const colorPool = ['#a43ec9', '#4caf50', '#ff4d4d', '#2196f3', '#ff9800', '#00bcd4', '#f06292', '#7e57c2', '#ffee58', '#8d6e63'];
        dashboardData.agentColors = {};
        let agentIndex = 0;
        Object.keys(dashboardData.agents).sort().forEach(name => { // Sort for consistent color assignment
            dashboardData.agentColors[name] = colorPool[agentIndex % colorPool.length];
            agentIndex++;
        });
    }

    // Modified processData to processDataForDisplay - operates on dashboardData.filteredCalls
    // This function will now primarily populate aggregates for display from `filteredCalls`
    function processDataForDisplay() {
      // Reset aggregates that depend on filtered data
      dashboardData.flags = {};
      dashboardData.positiveFlags = {};
      dashboardData.hourDistribution = new Array(24).fill(0);
      dashboardData.dayDistribution = new Array(7).fill(0);
      dashboardData.channelDistribution = {};
      dashboardData.queueDistribution = {};
      dashboardData.wordFrequency = {};
      // dashboardData.repeatCallers should be based on filteredCalls too
      dashboardData.repeatCallers = {}; 
      dashboardData.categories = {};
      
      // Agent stats for display (e.g. for Top Agents table) will be based on filtered calls
      // We must be careful not to overwrite dashboardData.agents which holds ALL agents for the filter.
      // Let's create a temporary structure for display-specific agent metrics.
      let displayAgentMetrics = {};

      dashboardData.filteredCalls.forEach(call => {
        const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
        if (!displayAgentMetrics[agent]) {
          displayAgentMetrics[agent] = {
            name: agent,
            totalCalls: 0,
            flaggedCalls: 0,
            positiveCalls: 0,
            positiveScore: 0,
            avgDuration: 0,
            totalDuration: 0
          };
        }
        
        const agentData = displayAgentMetrics[agent];
        agentData.totalCalls++;
        if (call.flags && call.flags.length > 0) agentData.flaggedCalls++;
        if (call.positiveFlags && call.positiveFlags.length > 0) agentData.positiveCalls++;
        agentData.positiveScore += (call.positiveScore || 0);
        const durationText = call.meta["Contact duration"] || "0";
        agentData.totalDuration += parseDuration(durationText);

        if (call.flags) {
          call.flags.forEach(flag => {
            dashboardData.flags[flag] = (dashboardData.flags[flag] || 0) + 1;
          });
        }
        if (call.positiveFlags) {
          call.positiveFlags.forEach(flag => {
            dashboardData.positiveFlags[flag] = (dashboardData.positiveFlags[flag] || 0) + 1;
          });
        }
        try {
          const timestamp = call.meta["Initiation timestamp"];
          if (timestamp) {
            const date = new Date(timestamp);
            if (!isNaN(date.getTime())) {
              dashboardData.hourDistribution[date.getHours()]++;
              dashboardData.dayDistribution[date.getDay()]++;
            }
          }
        } catch (error) { console.error("Error processing timestamp:", error); }
        
        const channel = call.meta["Channel"] || "Unknown";
        dashboardData.channelDistribution[channel] = (dashboardData.channelDistribution[channel] || 0) + 1;
        const queue = call.meta["Queue"] || "Unknown";
        dashboardData.queueDistribution[queue] = (dashboardData.queueDistribution[queue] || 0) + 1;

        if (call.transcript && call.transcript.length > 0) {
          call.transcript.forEach(entry => {
            if (entry.text) {
              const text = entry.text.toLowerCase();
              const words = text.split(/\\s+/).filter(word => 
                word.length > 3 && 
                !["this", "that", "what", "with", "have", "your", "from", "there", "would", "could", "about", "which", "just", "like", "it's", "yeah", "don't", "going", "gonna", "you're", "thank", "then", "know", "because", "they", "well", "need", "give", "take", "back", "right", "name", "alright", "when", "want", "here", "make", "let's", "will", "okay", "actually", "sorry", "able", "sure", "were", "been", "does", "doing", "should", "can't", "didn't", "isn't", "that's", "i'll", "we'll", "wasn't", "they're", "where", "their", "them", "these", "those", "some", "myself", "yourself", "himself", "herself", "please", "account", "information", "customer", "service", "contact", "number", "email", "phone", "call", "calling", "assistance", "help", "good", "time", "more", "only", "send", "still", "text", "data", "said", "today", "what's", "we're", "boost", "card", "digit", "yeah,", "you,", "here.", "know,", "right,", "yes,", "alright,", "that,", "bye,", "cxo-supcall-de-escalate", "credit_debit_number", "choosing", "payment", "cxo-wireless-call-issues", "i've"].includes(word)
              );
              words.forEach(word => {
                dashboardData.wordFrequency[word] = (dashboardData.wordFrequency[word] || 0) + 1;
              });
            }
          });
        }
        const customerPhone = call.meta["Customer phone number / email address"];
        if (customerPhone && customerPhone !== "Unknown" && customerPhone !== "N/A") {
          if (!dashboardData.repeatCallers[customerPhone]) {
            dashboardData.repeatCallers[customerPhone] = { phoneNumber: customerPhone, calls: [], flagCount: {}, firstCall: null, latestCall: null };
          }
          const callerRecord = dashboardData.repeatCallers[customerPhone];
          callerRecord.calls.push({ id: call.meta["Contact ID"], timestamp: call.meta["Initiation timestamp"], flags: call.flags || [], agent: agent });
          if (call.flags) {
            call.flags.forEach(flag => { callerRecord.flagCount[flag] = (callerRecord.flagCount[flag] || 0) + 1; });
          }
          const callTimestamp = call.meta["Initiation timestamp"];
          if (callTimestamp) {
            const date = new Date(callTimestamp);
            if (!isNaN(date.getTime())) {
              if (!callerRecord.firstCall || date < new Date(callerRecord.firstCall)) callerRecord.firstCall = callTimestamp;
              if (!callerRecord.latestCall || date > new Date(callerRecord.latestCall)) callerRecord.latestCall = callTimestamp;
            }
          }
        }
        if (call.meta["Categories"] && call.meta["Categories"] !== "N/A") {
          const categoryList = call.meta["Categories"].split(',').map(cat => cat.trim());
          categoryList.forEach(category => {
            if (category) dashboardData.categories[category] = (dashboardData.categories[category] || 0) + 1;
          });
        }
      });
      
      Object.values(displayAgentMetrics).forEach(agent => {
        agent.avgDuration = agent.totalCalls > 0 ? agent.totalDuration / agent.totalCalls : 0;
      });
      // Store this separately for display, so dashboardData.agents keeps all agents for filter
      dashboardData.displayAgentMetrics = displayAgentMetrics; 
    }
    
    // Parse duration string to minutes
    function parseDuration(durationText) {
      // Try to handle different duration formats
      if (!durationText) return 0;
      
      // Format: "HH:MM:SS"
      const timeMatch = durationText.match(/(\d+):(\d+):(\d+)/);
      if (timeMatch) {
        const hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3]);
        return hours * 60 + minutes + seconds / 60;
      }
      
      // Format: "X minutes Y seconds"
      const textMatch = durationText.match(/(\d+)\s*minutes?\s*(?:and\s*)?(?:(\d+)\s*seconds?)?/i);
      if (textMatch) {
        const minutes = parseInt(textMatch[1] || 0);
        const seconds = parseInt(textMatch[2] || 0);
        return minutes + seconds / 60;
      }
      
      // Try to parse as number
      const num = parseFloat(durationText);
      if (!isNaN(num)) return num;
      
      return 0;
    }
    
    // Refresh all dashboard elements
    function refreshDashboard() {
      if (!dashboardData.calls || dashboardData.calls.length === 0) { 
        dataStatus.textContent = "No data loaded to refresh.";
        dashboardData.loaded = false; 
        // Clear all dashboard elements if no data
        clearDashboardElements(); // Call a new function to clear out old data from UI
        return;
      }

      dataStatus.textContent = "üîÑ Re-processing and refreshing dashboard...";
      // processData(); // This should now be processDataForDisplay, which is called by applyFiltersAndRefresh or handleFilterChange
      applyFiltersAndRefresh(); // This will correctly re-filter and call processDataForDisplay
      
      // updateSummaryStats(); // Called by renderActiveTabContent or directly if needed before
      // No, updateSummaryStats should be called here before rendering tabs
      updateSummaryStats();

      const activeButton = document.querySelector('.tab-button.active');
      if (activeButton) {
          renderActiveTabContent(activeButton.dataset.tab);
      } else if (tabButtons.length > 0) {
          tabButtons[0].click(); 
      }
      dataStatus.textContent = `‚úÖ Dashboard refreshed with ${dashboardData.calls.length} calls.`;
    }
    
    // New function to clear dashboard elements
    function clearDashboardElements() {
        // Clear summary stats
        document.getElementById('totalCalls').textContent = '0';
        document.getElementById('flaggedCalls').textContent = '0';
        document.getElementById('positiveCalls').textContent = '0';
        document.getElementById('avgDuration').textContent = '0 min';

        // Clear charts by destroying them if they exist
        if (agentPerformanceChart) agentPerformanceChart.destroy();
        if (flagDistributionChart) flagDistributionChart.destroy();
        if (positiveIndicatorsChartActual) positiveIndicatorsChartActual.destroy();
        if (timeDistributionChart) timeDistributionChart.destroy();
        if (dayDistributionChart) dayDistributionChart.destroy();
        if (channelDistributionChart) channelDistributionChart.destroy();
        if (queueDistributionChart) queueDistributionChart.destroy();
        if (categoriesChart) categoriesChart.destroy();
        // Re-initialize chart variables to null
        agentPerformanceChart = flagDistributionChart = positiveIndicatorsChartActual = timeDistributionChart = null;
        dayDistributionChart = channelDistributionChart = queueDistributionChart = categoriesChart = null;

        // Clear tables and lists
        const noDataMsg = '<td colspan="5" class="no-data-message">No data available</td>';
        const originalRepeatCallersBody = document.getElementById('repeatCallersBodyOriginalLocation');
        if (originalRepeatCallersBody) originalRepeatCallersBody.innerHTML = `<tr>${noDataMsg}</tr>`;
        document.getElementById('repeatCallersBody').innerHTML = `<tr>${noDataMsg}</tr>`;
        
        document.getElementById('commonTopics').innerHTML = '<div class="no-data-message">No data available</div>';
        document.getElementById('categoryDetails').innerHTML = '<div class="no-data-message">No categories data available</div>';
        
        const originalTopAgentsBody = document.getElementById('topAgentsBodyOriginalLocation');
        if (originalTopAgentsBody) originalTopAgentsBody.innerHTML = `<tr>${noDataMsg}</tr>`;
        document.getElementById('topAgentsBody').innerHTML = `<tr>${noDataMsg}</tr>`;

        document.getElementById('positiveCallsListActual').innerHTML = '<div class="no-data-message">No data available</div>';

        // You might want to visually clear canvas elements too, e.g., by drawing a "No Data" message
        // For simplicity, destroying the chart instance usually suffices as Chart.js might clear it.
    }
    
    // Update summary statistics - MUST use filteredCalls
    function updateSummaryStats() {
      const callsToSummarize = dashboardData.filteredCalls; // USE FILTERED CALLS
      const totalCalls = callsToSummarize.length;
      let flaggedCalls = 0;
      let positiveCalls = 0;
      let totalDuration = 0;
      
      callsToSummarize.forEach(call => { // USE FILTERED CALLS
        if (call.flags && call.flags.length > 0) flaggedCalls++;
        if (call.positiveFlags && call.positiveFlags.length > 0) positiveCalls++;
        
        const durationText = call.meta["Contact duration"] || "0";
        totalDuration += parseDuration(durationText);
      });
      
      const avgDuration = totalCalls > 0 ? totalDuration / totalCalls : 0;
      
      // Update DOM
      document.getElementById('totalCalls').textContent = totalCalls;
      document.getElementById('flaggedCalls').textContent = flaggedCalls;
      document.getElementById('positiveCalls').textContent = positiveCalls;
      document.getElementById('avgDuration').textContent = avgDuration.toFixed(1) + ' min';
    }
    
    // Render the agent performance chart - MUST use displayAgentMetrics and agentColors
    function renderAgentPerformanceChart() {
      const canvasElement = document.getElementById('agentPerformanceChart');
      if (!canvasElement) { console.warn("Agent performance chart canvas not found"); return; }
      const ctx = canvasElement.getContext('2d');
      
      // Use displayAgentMetrics which is based on filteredCalls
      const agentsForChart = Object.values(dashboardData.displayAgentMetrics || {})
        .sort((a, b) => b.totalCalls - a.totalCalls)
        .slice(0, 10); // Top 10 by call volume from filtered data
      
      const labels = agentsForChart.map(a => a.name);
      const datasets = [
        {
          label: 'Positive Calls',
          data: agentsForChart.map(a => a.positiveCalls),
          backgroundColor: agentsForChart.map(a => dashboardData.agentColors[a.name] ? dashboardData.agentColors[a.name].replace(/, 1\)/, ', 0.7)') : 'rgba(76, 175, 80, 0.7)'),
          borderColor: agentsForChart.map(a => dashboardData.agentColors[a.name] || 'rgba(76, 175, 80, 1)'),
          borderWidth: 1
        },
        {
          label: 'Neutral Calls', // Assuming neutral = total - positive - flagged
          data: agentsForChart.map(a => Math.max(0, a.totalCalls - a.positiveCalls - a.flaggedCalls)),
          backgroundColor: 'rgba(158, 158, 158, 0.7)',
          borderColor: 'rgba(158, 158, 158, 1)',
          borderWidth: 1
        },
        {
          label: 'Flagged Calls',
          data: agentsForChart.map(a => a.flaggedCalls),
          backgroundColor: 'rgba(255, 77, 77, 0.7)',
          borderColor: 'rgba(255, 77, 77, 1)',
          borderWidth: 1
        }
      ];
      // If using agent specific colors, one approach for stacked bar is to create a dataset per agent per type
      // For simplicity here, if agentColors are available, we use the positive call color for that agent, otherwise default.
      // A more advanced setup would ensure each segment of the stack for an agent can be uniquely colored.
      // For now, let's color the 'Positive Calls' segment by agent color if available.
      // The first dataset (Positive Calls) will attempt to use agent specific colors.

      if (agentPerformanceChart) {
        agentPerformanceChart.destroy();
      }
      agentPerformanceChart = new Chart(ctx, {
        type: 'bar',
        data: { labels: labels, datasets: datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              stacked: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render the flag distribution chart - based on filteredCalls
    function renderFlagDistributionChart() {
      const canvasElement = document.getElementById('flagDistributionChart');
      if (!canvasElement) { console.warn("Flag distribution chart canvas not found"); return; }
      const ctx = canvasElement.getContext('2d');
      
      // dashboardData.flags is already populated from filteredCalls by processDataForDisplay
      const topFlags = Object.entries(dashboardData.flags)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8); // Top 8 flags
      
      // Prepare data
      const labels = topFlags.map(f => f[0]);
      const data = topFlags.map(f => f[1]);
      
      // Destroy existing chart if it exists
      if (flagDistributionChart) {
        flagDistributionChart.destroy();
      }
      
      // Create new chart
      flagDistributionChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Flag Occurrences',
            data: data,
            backgroundColor: 'rgba(255, 77, 77, 0.7)',
            borderColor: 'rgba(255, 77, 77, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render time distribution charts - based on filteredCalls
    function renderTimeDistributionCharts() {
      // dashboardData.hourDistribution and dayDistribution are from filteredCalls via processDataForDisplay
      const hourCanvas = document.getElementById('timeDistributionChart');
      if (!hourCanvas) {
        console.warn("Hour distribution chart canvas not found");
        return;
      }
      const hourCtx = hourCanvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (timeDistributionChart) {
        timeDistributionChart.destroy();
      }
      
      // Create labels for hours
      const hourLabels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      // Create new chart
      timeDistributionChart = new Chart(hourCtx, {
        type: 'bar',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Calls by Hour of Day',
            data: dashboardData.hourDistribution,
            backgroundColor: 'rgba(164, 62, 201, 0.7)',
            borderColor: 'rgba(164, 62, 201, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      // Day of week distribution chart
      const dayCanvas = document.getElementById('dayDistributionChart');
      if (!dayCanvas) {
        console.warn("Day distribution chart canvas not found");
        return;
      }
      const dayCtx = dayCanvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (dayDistributionChart) {
        dayDistributionChart.destroy();
      }
      
      // Create new chart
      dayDistributionChart = new Chart(dayCtx, {
        type: 'bar',
        data: {
          labels: dayNames,
          datasets: [{
            label: 'Calls by Day of Week',
            data: dashboardData.dayDistribution,
            backgroundColor: 'rgba(76, 175, 80, 0.7)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render channel and queue distribution charts - based on filteredCalls
    function renderChannelAndQueueCharts() {
      // dashboardData.channelDistribution and queueDistribution are from filteredCalls via processDataForDisplay
      const channelCanvas = document.getElementById('channelDistributionChart');
      if (!channelCanvas) {
        console.warn("Channel distribution chart canvas not found");
        return;
      }
      const channelCtx = channelCanvas.getContext('2d');
      
      // Prepare data
      const channelLabels = Object.keys(dashboardData.channelDistribution);
      const channelData = Object.values(dashboardData.channelDistribution);
      
      // Destroy existing chart if it exists
      if (channelDistributionChart) {
        channelDistributionChart.destroy();
      }
      
      // Create new chart
      channelDistributionChart = new Chart(channelCtx, {
        type: 'pie',
        data: {
          labels: channelLabels,
          datasets: [{
            data: channelData,
            backgroundColor: [
              'rgba(255, 99, 132, 0.7)',
              'rgba(54, 162, 235, 0.7)',
              'rgba(255, 206, 86, 0.7)',
              'rgba(75, 192, 192, 0.7)',
              'rgba(153, 102, 255, 0.7)',
              'rgba(255, 159, 64, 0.7)'
            ],
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
      
      // Queue distribution
      const queueCanvas = document.getElementById('queueDistributionChart');
      if (!queueCanvas) {
        console.warn("Queue distribution chart canvas not found");
        return;
      }
      const queueCtx = queueCanvas.getContext('2d');
      
      // Prepare data
      const queueLabels = Object.keys(dashboardData.queueDistribution);
      const queueData = Object.values(dashboardData.queueDistribution);
      
      // Destroy existing chart if it exists
      if (queueDistributionChart) {
        queueDistributionChart.destroy();
      }
      
      // Create new chart
      queueDistributionChart = new Chart(queueCtx, {
        type: 'pie',
        data: {
          labels: queueLabels,
          datasets: [{
            data: queueData,
            backgroundColor: [
              'rgba(54, 162, 235, 0.7)',
              'rgba(255, 99, 132, 0.7)',
              'rgba(255, 206, 86, 0.7)',
              'rgba(75, 192, 192, 0.7)',
              'rgba(153, 102, 255, 0.7)',
              'rgba(255, 159, 64, 0.7)'
            ],
            borderColor: '#2a2a2a',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#ccc'
              }
            }
          }
        }
      });
    }
    
    // Render categories chart - based on filteredCalls
    function renderCategoriesChart() {
      // dashboardData.categories is from filteredCalls via processDataForDisplay
      const canvasElement = document.getElementById('categoriesChart');
      if (!canvasElement) {
        console.warn("Categories chart canvas not found");
        return;
      }
      const ctx = canvasElement.getContext('2d');
      const categoryDetailsContainer = document.getElementById('categoryDetails');
      
      // Get categories data
      const categories = Object.entries(dashboardData.categories)
        .sort((a, b) => b[1] - a[1]) // Sort by count descending
        .slice(0, 10); // Top 10 categories
      
      // Check if we have data
      if (categories.length === 0) {
        categoryDetailsContainer.innerHTML = '<div class="no-data-message">No categories data available</div>';
        return;
      }
      
      // Prepare chart data
      const labels = categories.map(c => c[0]);
      const counts = categories.map(c => c[1]);
      
      // Create color array - gradient from green to purple
      const colors = counts.map((_, index) => {
        const ratio = index / (counts.length - 1);
        const r = Math.round(164 + (76 - 164) * ratio);
        const g = Math.round(62 + (175 - 62) * ratio);
        const b = Math.round(201 + (80 - 201) * ratio);
        return `rgba(${r}, ${g}, ${b}, 0.7)`;
      });
      
      // Destroy existing chart if it exists
      if (categoriesChart) {
        categoriesChart.destroy();
      }
      
      // Create new chart
      categoriesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Call Count',
              data: counts,
              backgroundColor: colors,
              borderColor: colors.map(c => c.replace('0.7', '1')),
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#ccc'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#ccc'
              }
            },
            title: {
              display: true,
              text: 'Top Call Categories',
              color: '#ccc',
              font: {
                size: 16
              }
            }
          }
        }
      });
      
      // Update category details section with table
      let detailsHtml = `
        <h3 style="font-size: 16px; margin-bottom: 10px; color: #aaa;">Category Distribution (Filtered)</h3>
        <table style="width: 100%;">
          <thead>
            <tr>
              <th style="text-align: left;">Category</th>
              <th style="text-align: right;">Count</th>
              <th style="text-align: right;">Percentage</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      const totalFilteredCalls = dashboardData.filteredCalls.length; // Use filtered total
      categories.forEach(([category, count]) => {
        const percentage = totalFilteredCalls > 0 ? (count / totalFilteredCalls * 100).toFixed(1) : 0; // Check totalFilteredCalls
        detailsHtml += `
          <tr>
            <td style="text-align: left;">${category}</td>
            <td style="text-align: right;">${count}</td>
            <td style="text-align: right;">${percentage}%</td>
          </tr>
        `;
      });
      
      detailsHtml += `
          </tbody>
        </table>
      `;
      
      categoryDetailsContainer.innerHTML = detailsHtml;
    }
    
    // Update the repeat callers table - based on filteredCalls
    function updateRepeatCallersTable() {
      // dashboardData.repeatCallers is from filteredCalls via processDataForDisplay
      const tableBody = document.getElementById('repeatCallersBody');
      if(!tableBody) {
        console.warn("Repeat callers table body not found. Original or new.");
        return;
      }
      // Get callers with multiple calls
      const repeatCallers = Object.values(dashboardData.repeatCallers)
        .filter(caller => caller.calls.length > 1)
        .sort((a, b) => b.calls.length - a.calls.length);
      
      // Clear table
      tableBody.innerHTML = '';
      
      // No data case
      if (repeatCallers.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" class="no-data-message">No repeat callers found</td>';
        tableBody.appendChild(row);
        return;
      }
      
      // Add rows (limited to top 10)
      repeatCallers.slice(0, 10).forEach(caller => {
        const row = document.createElement('tr');
        
        // Get top flags for this caller
        const topFlags = Object.entries(caller.flagCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([flag, count]) => `${flag} (${count})`)
          .join(', ');
        
        // Format phone number for privacy
        const phoneDisplay = caller.phoneNumber.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
        
        row.innerHTML = `
          <td>${phoneDisplay}</td>
          <td>${caller.calls.length}</td>
          <td>${caller.latestCall ? new Date(caller.latestCall).toLocaleString() : 'Unknown'}</td>
          <td>${caller.firstCall ? new Date(caller.firstCall).toLocaleString() : 'Unknown'}</td>
          <td>${topFlags || 'None'}</td>
        `;
        
        tableBody.appendChild(row);
      });
    }
    
    // Update common topics - based on filteredCalls
    function updateCommonTopics() {
      // dashboardData.wordFrequency is from filteredCalls via processDataForDisplay
      const container = document.getElementById('commonTopics');
      
      // Get top words
      const topWords = Object.entries(dashboardData.wordFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 40); // Top 40 words
      
      // Clear container
      container.innerHTML = '';
      
      // No data case
      if (topWords.length === 0) {
        const message = document.createElement('div');
        message.className = 'no-data-message';
        message.textContent = 'No word frequency data available';
        container.appendChild(message);
        return;
      }
      
      // Calculate max frequency for scaling
      const maxFrequency = topWords[0][1];
      
      // Add words as tags
      topWords.forEach(([word, count]) => {
        // Scale font size based on frequency
        const fontSize = Math.max(12, Math.min(24, 12 + (count / maxFrequency) * 12));
        const opacity = 0.5 + (count / maxFrequency) * 0.5;
        
        const wordElement = document.createElement('div');
        wordElement.style.fontSize = `${fontSize}px`;
        wordElement.style.padding = '3px 8px';
        wordElement.style.margin = '3px';
        wordElement.style.borderRadius = '10px';
        wordElement.style.background = `rgba(255, 255, 255, ${opacity * 0.1})`;
        wordElement.style.color = '#eee';
        wordElement.title = `${count} occurrences`;
        wordElement.textContent = word;
        
        container.appendChild(wordElement);
      });
    }
    
    // Update the top agents table - MUST use displayAgentMetrics
    function updateTopAgentsTable() {
      const tableBody = document.getElementById('topAgentsBody');
      if(!tableBody) {
        console.warn("Top agents table body not found. Original or new.");
        return;
      }
      
      // Use displayAgentMetrics which is based on filteredCalls and processed by processDataForDisplay
      const sortedAgents = Object.values(dashboardData.displayAgentMetrics || {})
        .map(agent => {
          const positiveRatio = agent.totalCalls > 0 ? 
            (agent.positiveCalls / agent.totalCalls) : 0;
          // avgScore is already calculated as part of total positiveScore / totalCalls in displayAgentMetrics
          // but let's ensure it's used correctly
          const avgScoreDisplay = agent.totalCalls > 0 ? (agent.positiveScore / agent.totalCalls) : 0;
            
          return {
            ...agent, // contains name, totalCalls, avgDuration (already calculated)
            positiveRatio,
            avgScore: avgScoreDisplay 
          };
        })
        .sort((a, b) => b.avgScore - a.avgScore) // Sort by average positive score
        .slice(0, 10); // Top 10
      
      // Clear table
      tableBody.innerHTML = '';
      
      // No data case
      if (sortedAgents.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" class="no-data-message">No data available</td>';
        tableBody.appendChild(row);
        return;
      }
      
      // Add rows
      sortedAgents.forEach(agent => {
        const row = document.createElement('tr');
        
        row.innerHTML = `
          <td>${agent.name}</td>
          <td>${agent.totalCalls}</td>
          <td>${(agent.positiveRatio * 100).toFixed(1)}%</td>
          <td>${agent.avgScore.toFixed(2)}</td>
          <td>${agent.avgDuration.toFixed(1)} min</td>
        `;
        
        tableBody.appendChild(row);
      });
    }
    
    // New function for the positive calls list in the "Positive" tab - based on filteredCalls
    function updatePositiveCallsListActual() {
        console.log("[Debug] updatePositiveCallsListActual called");
        // Use filteredCalls directly
        const positiveCallsSource = dashboardData.filteredCalls.filter(call => call.positiveScore > 0);
        console.log("[Debug] Calls with positiveScore > 0 (from filteredCalls):", JSON.parse(JSON.stringify(positiveCallsSource)));

        const container = document.getElementById('positiveCallsListActual');
        if (!container) {
            console.warn('Container for actual positive calls list not found.');
            return;
        }

        // Clear container
        container.innerHTML = '';

        // No data case
        if (positiveCallsSource.length === 0) {
            const message = document.createElement('div');
            message.className = 'no-data-message';
            message.textContent = 'No positive calls available';
            container.appendChild(message);
            return;
        }

        // Add positive calls
        positiveCallsSource.forEach(call => {
            const agent = call.meta["Agent"] || call.meta["Agent name"] || "Unknown";
            const date = call.meta["Initiation timestamp"] || "Unknown date";
            const duration = call.meta["Contact duration"] || "Unknown";

            const callElement = document.createElement('div');
            callElement.style.margin = '0 0 15px 0';
            callElement.style.padding = '10px';
            callElement.style.background = 'rgba(76, 175, 80, 0.05)';
            callElement.style.borderLeft = '3px solid #4caf50';

            callElement.innerHTML = `
              <div><strong>${agent}</strong> - ${new Date(date).toLocaleString()} - Duration: ${duration}</div>
              <div>Positive Score: <span class="positive-color">${call.positiveScore}</span></div>
              <div>
                ${call.positiveFlags.map(flag =>
                `<span style="display: inline-block; margin: 3px; padding: 2px 6px; background: rgba(76, 175, 80, 0.1); border-radius: 3px; color: #4caf50;">${flag}</span>`
            ).join('')}
              </div>
              ${call.summary ? `<div style="margin-top: 5px; font-style: italic; color: #aaa;">${call.summary}</div>` : ''}
            `;

            container.appendChild(callElement);
        });
    }
  </script>
</body>
</html>

